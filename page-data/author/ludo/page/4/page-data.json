{"componentChunkName":"component---src-templates-author-tsx","path":"/author/ludo/page/4","webpackCompilationHash":"ba1a271305926245155b","result":{"data":{"authorYaml":{"id":"ludo","name":"Wyffels Ludovic","website":"https://ludovicwyffels.github.io","twitter":"WYFFELSLudovic","bio":"Développeur senior. Fullstack + DevOps","facebook":"ludovicwyffels","location":"Comines, Belgique","profile_image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/5f2c129e42248a92c87b13b4293950cf/647de/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/647de/ghost.png 400w","sizes":"(max-width: 400px) 100vw, 400px"}}},"avatar":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/5f2c129e42248a92c87b13b4293950cf/7c0ed/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/09f8c/ghost.png 50w,\n/static/5f2c129e42248a92c87b13b4293950cf/bf65b/ghost.png 100w,\n/static/5f2c129e42248a92c87b13b4293950cf/7c0ed/ghost.png 200w,\n/static/5f2c129e42248a92c87b13b4293950cf/fdbb0/ghost.png 300w,\n/static/5f2c129e42248a92c87b13b4293950cf/647de/ghost.png 400w","sizes":"(max-width: 200px) 100vw, 200px"}}}},"allMarkdownRemark":{"totalCount":32,"edges":[{"node":{"excerpt":"Souvent, je me trouve aux prises avec Sequelize pour trouver une réponse directe à ma requête. Récemment, je travaillais sur une application full stack dans laquelle il était impératif de paginer les résultats depuis le backend (API REST) vers le client. Je me suis battu pour deux raisons. Tout d’abord, venant du context NoSQL, il est difficile de saisir les bases de données SQL. La deuxième raison étant que la documentation de Sequelize ne fournit pas une solution claire et directe à cette abstraction très basique. Beaucoup de gens supposent des choses dans le monde des bases de données SQL. Ainsi, dans cet article, nous allons parler d’un module de base de pagination utilisant Sequelize, MySQL et Node.js. J’utilise des tables et des enregistrements dans votre base de données MySQL. Pour configurer une nouvelle application et établir une connexion à une base de données, lisez mon post sur Premiers pas avec Sequelize. Définir un modèle Je saute directement sur la définition du modèle utilisateur: J’utilise une table contenant une centaine d’enregistrements d’utilisateur que nous voulons afficher sur une application Web, par exemple dans le panneau d’administration, et nous voulons afficher seulement 50 enregistrements à la fois. Dans le fichier api/user.js, je définis un endpoint /:page qui extraira le nombre de résultats nécessaires de la base de données. findAndCountAll est le modèle de recherche dans plusieurs enregistrements de la base de données. Il retourne à la fois les données requises et le nombre d’éléments de cette table. La requête ci-dessus obtiendra 50 enregistrements d’utilisateur à la fois jusqu’à ce que la page suivante soit appelée pour extraire les 50 prochains enregistrements. limit et offset sont nécessaires dans les requêtes liées à la pagination dans lesquelles limit extrait le nombre de lignes en fonction de la requête, tandis que offset est utilisé pour ignorer le nombre","timeToRead":1,"frontmatter":{"title":"Comment paginer des enregistrements dans MySQL avec Sequelize et Nodejs","subtitle":"","tags":["Sequelize","Node.js","Javascript"],"date":"2018-10-13T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABc/i1RhGH/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAMBAhEEE//aAAgBAQABBQKvRtmuqontsQqdanTwP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/Aar/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGI/8QAHBAAAQMFAAAAAAAAAAAAAAAAAAEiMQIREjLh/9oACAEBAAY/An0mV5g4bqI4k//EABoQAQACAwEAAAAAAAAAAAAAAAEAESFBUfH/2gAIAQEAAT8hKyhSrJs7VFOGpdNmVqHIjzP/2gAMAwEAAgADAAAAEOPv/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8QhD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/EA//xAAfEAEAAgIABwAAAAAAAAAAAAABABEhMUFRYXGhsfD/2gAIAQEAAT8Q65gFNZ8S8YYMuKrcvBhNcPuECl5hEFdEsYiW1/O8/9k=","aspectRatio":1.4992503748125936,"src":"/static/e47b6c69cbe49a04cdbe6e0e621f405f/883ab/open-book.jpg","srcSet":"/static/e47b6c69cbe49a04cdbe6e0e621f405f/f8f18/open-book.jpg 930w,\n/static/e47b6c69cbe49a04cdbe6e0e621f405f/0e6ff/open-book.jpg 1860w,\n/static/e47b6c69cbe49a04cdbe6e0e621f405f/883ab/open-book.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/node-sequelize-pagination/"}}},{"node":{"excerpt":"Introduction à l’ORM ORM ou Object Relation Mapping est un processus de mappage entre des objets et des systèmes de base de données relationnels. Un ORM agit comme une interface entre deux systèmes. Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier. Le code est robuste au lieu de redondant. ORM aide à gérer les requêtes sur plusieurs tables de manière efficace. Enfin, un ORM (comme sequelize) est capable de se connecter à différentes bases de données (ce qui est pratique lors du passage d’une base de données à une autre). Démarrer avec Sequelize Débuter avec Sequelize Sequelize est un ORM basé sur des promesses pour Node.js. Sequelize est facile à apprendre et possède des dizaines de fonctionnalités intéressantes comme la synchronisation, l’association, la validation, etc. Il prend également en charge PostgreSQL, MySQL, MariaDB, SQLite et MSSQL. J’utilise actuellement PostgreSQL. Installation Sequelize est disponible via npm. Établissement d’une connexion Sequelize établit une connexion entre l’API / application restante et votre base de données SQL. Pour configurer la connexion de base entre les deux:","timeToRead":1,"frontmatter":{"title":"Démarrer avec Sequelize","subtitle":"Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier.","tags":["Sequelize","Node.js","Javascript"],"date":"2018-10-12T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAUlEQVQoz2P4DwP//v//8+//33//iQcM2AT/AQGxmiEK3/3+33H75/Jnf/4QbzPEjucff7ptfym87JHMiofVO67fv/v489fvQPt//Pz19+9fkNHvP3389PXXrz+/fyMMZ/gL1n3p8Se7vhNS9buVchfm180+c+HW1j2n9x+5uGnHicvXHmzedXLdliOnzt3cffD8+q1Hf/78hWLz3VdffSefMq3bZhbdXt264O37z7fuPn3+8t3Zi7fvPXh++97Tx09fv3j1/t6jF/cePv8DdguKn689/1q37MyM+VvevP0ICTTSQvv3H6gWIPnvHzTMYWwUQXTNEGE0aTLi+T89NAMA0+5wRDWkongAAAAASUVORK5CYII=","aspectRatio":1.7777777777777777,"src":"/static/335caa592debcad471a1ec9936833b1b/9ecf6/sequelize.png","srcSet":"/static/335caa592debcad471a1ec9936833b1b/4c9af/sequelize.png 930w,\n/static/335caa592debcad471a1ec9936833b1b/9ecf6/sequelize.png 1600w","sizes":"(max-width: 1600px) 100vw, 1600px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/node-sequelize-intro/"}}},{"node":{"excerpt":"La plupart des exemples de code couvrant le kit AWS SDK comme ci-dessous, c’est à dire qu’ils importent l’intégralité du kit AWS même s’ils utilisent seulement quelques services AWS, parfois un seul (AWS DynamoDB).  Cependant, la méthode recommandée pour initialiser divers clients de service AWS consiste à ne les importer que lorsque nécessaire, comme ci-dessous. Économise des temps de chargement et de la mémoire précieux, particulièrement utile dans les environnements à ressources de calcul comme un périphérique IoT ou dans une fonction AWS Lamba.  NB: vous pouvez toujours accéder à l’espace de noms AWS global sans chaque service AWS associé en écrivant sous le code. Cette technique est utile lorsque vous appliquez la même configuration à plusieurs services AWS individuels, par exemple pour fournir les mêmes informations d’identification à tous les services AWS. const aws = require('aws-sdk/global'); Consultez la documentation officielle d’AWS pour plus d’informations ci-dessous. https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/creating-and-calling-service-objects.html Bonne programmation!","timeToRead":2,"frontmatter":{"title":"AWS SDK pour Node.js: Meilleures pratiques","subtitle":"","tags":["AWS","Amazon Web Service","Node.js"],"date":"2018-09-23T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsTAAALEwEAmpwYAAABm0lEQVQoz6VSS0sCURj1p7QKIghatGrTIpNS0zQXIQnqohlHpmYENy3S1AZntLBk5r7mjk96QVGbIFq5alH7Fm2iqGV/oTsp9oIedOAeLt/l8J3zfdeB/gHHlwp8x38RQ4QBohARw2b8KzFGkCCDIEBR9ZBkLLh1gNcI2AEAQvu8AQDwWQwQ0WGtAvaOzdW79sjD3ujz/kCnJQDSoiYmhJgM1CbLsj6ImckG3uzUImdUvKrPXtfdjVLsaDtcWpdVtayqxXK5XHxFSdMKhYJhGBj3EjlYzxMz/dgevG8NP+0OncOFCWfINR1wTbmDfr/f6wsFgj6Pd34u4JmZcU06lQ2FUsoidG1DA9JTmr5tjl02FirbejLBpeSVlWUxJacSfCLB87IkJQVhWWQVWVM1FqTXGdtia5coN83xixpfqSKeW4pGo4uRiCRJ4XBYEARRFDmOi8fjsVgsl8v1nXdXxUxg1p/tic2TPWcymWw2qygKY01lwYssbT6fZ6zr+lvm/o4xAvj1b9ijpbQ3ZNPsX7r4/och+C1+EP8eL/ttumw4YiedAAAAAElFTkSuQmCC","aspectRatio":1.6,"src":"/static/7df7623d3341dedb9671ec0dd508de83/91f24/aws.png","srcSet":"/static/7df7623d3341dedb9671ec0dd508de83/4c9af/aws.png 930w,\n/static/7df7623d3341dedb9671ec0dd508de83/91f24/aws.png 1280w","sizes":"(max-width: 1280px) 100vw, 1280px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/aws-sdk/"}}},{"node":{"excerpt":"Flex Flex est un ensemble de règles pour étirer automatiquement plusieurs colonnes et lignes de contenu dans son conteneur parent. display:flex Contrairement à de nombreuses autres propriétés CSS, vous disposez d’un conteneur principal et d’éléments imbriqués dans Flex. Certaines propriétés CSS flex sont utilisées uniquement sur le parent. D’autres seulement sur les items.  Vous pouvez considérer un élément flex comme un conteneur parent avec display: flex. Les éléments placés à l’intérieur de ce conteneur sont appelés items. Chaque conteneur a un point flex-start et flex-end comme indiqué dans le diagramme ci-dessus. Axe principal et axe croisé Alors que la liste des items est fournie de manière linéaire, Flex vous oblige à tenir compte des lignes et des colonnes. Pour cette raison, il a deux axes de coordonnées. L’axe horizontal est appelé axe principal (Main-Axis) et la verticale est l’axe croisé (Cross-Axis). Pour contrôler le comportement de la largeur du contenu et des écarts entre les deux, et pour lui permettre de s’étendre horizontalement sur l’axe principal, vous utiliserez des propriétés de justification. Pour contrôler le comportement vertical des éléments, vous utiliserez les propriétés d’alignement. Si vous avez 3 colonnes et 6 éléments, une deuxième ligne sera créée automatiquement par Flex pour accueillir les items restants. Si vous avez répertorié plus de 6 éléments, d’autres lignes seront créées.  Les éléments Flex sont également répartis sur l’axe principal. Nous allons examiner les propriétés et les valeurs pour y parvenir dans un instant.  Vous pouvez déterminer le nombre de colonnes. La façon dont les lignes et les colonnes sont distribuées dans l’élément parent est déterminée par les propriétés CSS Flex flex-direction, flex-wrap et quelques autres qui seront démontrées tout au long de cet article.  Ici, nous avons un nombre n arbitraire d’éléments placés dans un conteneur. Par défaut, les éléments s’étendent de gauche à droite. Cependant, le point d’origine peut être inversé. Direction Il est possible de définir la direction du flex de l’élément en l’inversant.   flex-direction:row-reverse change la direction du flux de la liste d’éléments. La valeur par défaut est row, ce qui veut dire que ça va de gauche à droite, comme on s’y attendrait! Wrap  flex-wrap:wrap détermine comment les éléments sont encapsulés lorsque le conteneur parent manque d’espace. Flow  flex-flow est un raccourci pour flex-direction et flex-wrap, vous permettant de spécifier les deux en utilisant un seul nom de propriété.  flex-flow:row wrap détermine flex-direction à être row et flex-wrap à être wrap.       Lorsque nous changeons la direction du flex en colonne, la propriété flex-flow se comporte exactement de la même manière que dans les exemples précédents. Sauf cette fois, ils suivent la direction verticale d’une colonne.  justify-content  Dans cet exemple, nous n’utilisons que 3 éléments par ligne. Il n’y a aucune limite sur le nombre d’articles que vous souhaitez utiliser en flex. Ces diagrammes montrent uniquement le comportement des éléments lorsque l’une des valeurs répertoriées est appliquée à la propriété justify-content.  la même propiété justify-content est utilisée pour aligner les éléments lorsque flex-direction est en colonne. Packing flex lines (selon la spécification Flex)  La spécification Flex se réfère à ceci comme ”packing flex lines”. Fondamentalement, cela fonctionne exactement comme les exemples que nous avons vu dans les images précédentes. Sauf cette fois, notez que l’espacement est entre les ensembles entiers d’articles. Ceci est utile lorsque vous souhaitez créer des vides autour d’un lot de plusieurs éléments.  Packing Flex Lines (suite.) Mais maintenant avec flex-direction: column. align-items  align-items contrôle l’alignement des éléments horizontalement par rapport au conteneur parent flex-basis  flex-basis fonctionne de manière similaire à une autre propriété CSS: min-width outside of flex. Il va augmenter la taille d’un objet en fonction du contenu interne. Sinon, la valeur de base par défaut sera utilisée. flex-grow  flex-grow, lorsqu’il est appliqué à un élément, il est mis à l’échelle par rapport à la somme de la taille de tous les autres éléments de la même ligne, qui sont automatiquement ajustés en fonction de la valeur spécifiée. Dans chaque exemple, la valeur flex-grow de l’élément a été définie sur 1, 7 et (3 et 5) dans le dernier exemple. flex-shrink  flex-shrink est le contraire de flex-grow. Dans cet exemple, une valeur de 7 a été utilisée pour “réduire” l’élément sélectionné dans la quantité égale à 1/7 de la taille de ses éléments environnants - qui seront également ajustés automatiquement.  Lorsque vous traitez des éléments individuels, vous pouvez utiliser la propriété flex comme raccourci pour flex-grow, flex-shrink et flex-basis en utilisant un seul nom de propiété. order En utilisant la propriété order, il est possible de réorganiser l’ordre naturel des objets.  justify-items","timeToRead":8,"frontmatter":{"title":"Flexbox illustré","subtitle":"Flex est un ensemble de règles pour étirer automatiquement plusieurs colonnes et lignes de contenu dans son conteneur parent.","tags":["CSS","Flexbox","Style"],"date":"2018-07-12T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAABMElEQVQoz32STUvDQBCG82elEMzujqUt2BYTD6Y5WA8SknoRigi2JqbNl0URPAmtGNumsSr+F2fz0UNshYfl3Z2d2XdnV5DEPaLUtyDXJBC3h5DjBpEqAmlXIQnKfIQwH9OeBqtgS3Tlw9eEaK00GSclcMf7iJodWHoQFyR+LpYurEPS2Znsw8IlZwob6swyMmi/m+tbg931SPPgn5PH1FAhctAC582hAx3vwjUuxh45OUyTY7/A22l74VLb5KGybWwPwvuUsrHdlenNOR3qGeTydKOpZaS2W1X2MoCpBa82zGyIRrww5kcONVWYu1glJ/ZzgeaTgKhNAQuwqcUe++zpio/P1/x5vidoj15osL6Hz4KNXofw80C0tsA/Cb54hpIi1zlHNYmJuf6L0pD2K7/yK1/DQbhWLAAAAABJRU5ErkJggg==","aspectRatio":2.0075282308657467,"src":"/static/4e715df533b5882aeb279a15be76bc08/9ecf6/flexbox.png","srcSet":"/static/4e715df533b5882aeb279a15be76bc08/4c9af/flexbox.png 930w,\n/static/4e715df533b5882aeb279a15be76bc08/9ecf6/flexbox.png 1600w","sizes":"(max-width: 1600px) 100vw, 1600px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/css-flexbox-illustre/"}}},{"node":{"excerpt":"Les conteneurs d’applications ont émergé comme un outil puissant dans le développement de logiciels modernes. Plus légers et plus économes en ressources que les machines virtuelles traditionnelles, les conteneurs offrent aux organisations informatiques de nouvelles opportunités dans le contrôle de version, le déploiement, la graduation (scaling) et la sécurité. Ce post traitera de ce que sont exactement les conteneurs, pourquoi ils se révèlent si avantageux, comment les utilisateurs les utilisent et des meilleures pratiques pour conteneuriser vos applications Node.js avec Docker. Qu’est-ce qu’un conteneur ? En termes simples, les conteneurs exécutent des instances d’ images de conteneur. Les images sont des alternatives en couches aux disques de machines virtuelles (VMD) qui permettent aux applications d’être extraites de l’environnement dans lequel elles sont réellement exécutées. Les images conteneur sont exécutables, logiciel isolé avec accès aux ressources de l’hôte, au réseau et au système de fichiers. Ces images sont créées avec leurs propres outils système, bibliothèques, code, environnement d’exécution et dépendances associées codées en dur. Cela permet aux conteneurs d’être filés indépendamment de l’environnement. Cette approche “tout-en-un” aide à résoudre les problèmes d’application indépendante, en améliorant la sécurité des systèmes et en facilitant le débogage. Contrairement aux machines virtuelles traditionnelles, les images de conteneur donnent à chacune de ses instances un accès partagé au système d’exploitation hôte via une exécution de conteneur. Cet accès partagé aux ressources du système hôte permet d’obtenir des performances et des ressources qui ne sont pas trouvées dans d’autres méthodes de virtualisation.  Imaginez une image de conteneur qui nécessite 500 Mo. Dans un environnement conteneurisé, ces 500 Mo peuvent être partagés entre des centaines de conteneurs en supposant qu’ils fonctionnent tous sur la même image de base. D’un autre côté, les machines virtuelles auraient besoin de 500 Mo par machine virtuelle . Cela rend les conteneurs beaucoup plus adaptés aux horizontal scaling et aux environnements restreints aux ressources. Pourquoi les conteneurs d’applications ? La légèreté et la reproductibilité des conteneurs en ont fait une option de plus en plus utilisée par les entreprises souhaitant développer des applications logicielles évolutives, hautement disponibles et contrôlées par les versions. Les conteneurs offrent plusieurs avantages clés aux développeurs: Léger et économe en ressources. Par rapport aux machines virtuelles, qui génèrent des copies de leur système d’exploitation hôte pour chaque application ou processus, les conteneurs ont nettement moins d’impact sur la mémoire, l’utilisation du processeur et l’espace disque. Immuable. Les conteneurs sont générés à partir d’une seule source vérifiée, une image. Si des modifications sont validées sur une image, une nouvelle image est créée . Cela rend les changements d’image de conteneur faciles à suivre et les restaurations de déploiement intuitives. La reproductibilité et la stabilité des conteneurs permettent aux équipes de développement d’éviter la dérive de la configuration, ce qui simplifie considérablement le test de version et la mise en miroir des environnements de développement et de production. Portable. La nature isolée et autonome des conteneurs en fait un excellent choix pour les applications qui doivent fonctionner sur une multitude de services, de plates-formes et d’environnements. Ils peuvent fonctionner sous Linux, Windows et macOS. Fournissez-les depuis le cloud, sur site ou là où votre infrastructure l’exige. Évolutif et hautement disponible. Les conteneurs sont facilement reproductibles et peuvent répondre dynamiquement aux demandes de trafic, grâce aux services d’orchestration tels que les instances de conteneur Azure, Google Cloud Engine et Amazon ECS, qui facilitent et accélèrent la création ou le retrait de conteneurs de votre infrastructure. Cas d’utilisation de conteneurs d’applications Toutes les applications et les organisations n’auront pas les mêmes besoins en infrastructure. Les avantages susmentionnés des conteneurs les rendent particulièrement aptes à répondre aux besoins suivant: DEVOPS ORGANISATIONS Pour les équipes qui travaillent à pratiquer «l’infrastructure comme code» et qui cherchent à adopter le paradigme DevOps, les conteneurs offrent des opportunités inégalées. Leur portabilité, leur résistance à la dérive de configuration et leur temps de démarrage rapide font des conteneurs un excellent outil pour tester rapidement et de manière reproductible différents environnements de code, indépendamment de la machine ou de l’emplacement. MICROSERVICE ET ARCHITECTURES DISTRIBUÉES Une expression courante dans le développement de microservices est «faites une chose et faites-le bien», et cela s’harmonise étroitement avec les conteneurs d’applications. Les conteneurs offrent un excellent moyen d’envelopper les microservices et de les isoler de l’environnement d’application plus large. Ceci est très utile lorsque vous souhaitez mettre à jour des (micro-) services spécifiques d’une suite d’applications sans mettre à jour l’ensemble de l’application. TESTS A / B Les conteneurs facilitent le déploiement de plusieurs versions de la même application. Lorsqu’ils sont associés à des déploiements incrémentaux , les conteneurs peuvent maintenir votre application dans un état dynamique et réactif aux tests. Voulez-vous tester une nouvelle fonctionnalité de performance? Faites défiler un nouveau conteneur, ajoutez des mises à jour, acheminez 1% du trafic vers celui-ci et collectez des commentaires sur les utilisateurs et les performances. À mesure que les changements se stabilisent et que votre équipe décide de l’appliquer à l’application en général, les conteneurs peuvent rendre cette transition fluide et efficace. Conteneurs et Node.js En raison de la pertinence des conteneurs d’applications pour les environnements d’application ciblés, Node.js est sans doute le meilleur moteur d’exécution pour la conteneurisation. Dépendances explicites. Les applications Node.js conteneurisées peuvent verrouiller les arborescences de dépendance et gérer des fichiers stables package.json , package-lock.json ou npm-shrinkwrap.json . Démarrage rapide et redémarrage. Les conteneurs sont légers et démarrent rapidement, ce qui en fait une paire stratégique pour les applications Node.js. L’une des fonctionnalités les plus appréciées de Node.js est son temps de démarrage impressionnant. Cette performance de démarrage robuste obtient des processus terminés redémarrés rapidement et les applications stabilisées; La conteneurisation fournit une solution évolutive pour maintenir cette performance. Scaling au niveau du processus. Semblable à la meilleure pratique de Node.js consistant à faire tourner plus de processus au lieu de plus de threads, un environnement conteneurisé augmentera le nombre de processus en augmentant le nombre de conteneurs. Cet horizontal scaling crée de la redondance et permet de maintenir les applications hautement disponibles, sans le coût significatif des ressources d’une nouvelle machine virtuelle par processus. Dockeriser votre application Node.js Présentation de Docker Docker est un système de fichiers en couches pour l’envoi d’images, et permet aux organisations d’abstraire leurs applications de leur infrastructure. Avec Docker, les images sont générées via un fichier Docker. Ce fichier fournit des configurations et des commandes pour générer des images par programme. Chaque commande Docker dans un Dockerfile ajoute un ‘calque’. Plus il y a de couches, plus le conteneur résultant est grand. Voici un exemple simple de Dockerfile:  La commande FROM désigne l’image de base qui sera utilisée; dans ce cas, il s’agit de l’image de la ligne de lancement Node.js 8 LTS. La commande RUN prend les commandes bash comme arguments. Dans la ligne 2, nous créons un répertoire pour placer l’application Node.js. La ligne 3 indique à Docker que le répertoire de travail pour chaque commande après la ligne 3 sera le répertoire de l’application. La ligne 5 copie tout le répertoire courant dans le répertoire courant de l’image, qui est /home/nodejs/app précédemment défini par la commande WORKDIR de manière similaire. Sur la ligne 6, nous installons l’installation de production. Enfin, sur la ligne 8, nous transmettons à Docker une commande et un argument pour exécuter l’application Node.js à l’intérieur du conteneur. L’exemple ci-dessus fournit un Dockerfile de base, mais finalement problématique. Dans la section suivante, nous examinerons certaines des meilleures pratiques de Dockerfile pour exécuter Node.js en production. Meilleures pratiques Dockerfile NE PAS EXÉCUTER L’APPLICATION EN TANT QUE ROOT Assurez-vous que l’application exécutée dans le conteneur Docker n’est pas exécutée en tant que root.  Dans l’exemple ci-dessus, quelques lignes de code ont été ajoutées à l’exemple Dockerfile d’origine pour extraire l’image de la dernière version LTS de Node.js, ainsi que pour ajouter et définir un nouvel utilisateur, nodejs . De cette façon, dans le cas où une vulnérabilité de l’application est exploitée, et que quelqu’un réussit à entrer dans le conteneur au niveau du système, au mieux, ce sont des utilisateurs nodejs qui n’ont pas d’autorisations root et n’existent pas sur l’hôte. CACHE NODE_MODULES Docker construit chaque ligne d’un Dockerfile individuellement. Cela forme les “couches” de l’image Docker. Au fur et à mesure qu’une image est construite, Docker met en cache chaque couche.  Sur la ligne 9 du Dockerfile ci-dessus, le fichier package.json est copié dans le répertoire de travail établi sur la ligne 7. Après le npm install sur la ligne 10, la ligne 11 copie le répertoire courant dans le répertoire de travail (l’image). Si aucune modification n’est apportée à votre package.json , Docker ne reconstruira pas la couche d’image npm install, ce qui peut considérablement améliorer les temps de construction. CONFIGUREZ VOTRE ENVIRONNEMENT Il est important de définir explicitement les variables d’environnement que votre application Node.js s’attend à rester constante tout au long du cycle de vie du conteneur.  DockerHub fournit une ressource centralisée pour la découverte d’images de conteneur, la distribution et la gestion des modifications, la collaboration entre utilisateurs et équipes et l’automatisation du flux de travail tout au long du pipeline de développement’.\nPour associer la CLI Docker à votre compte DockerHub, utilisez la docker login  docker login [OPTIONS] [SERVER] : docker login [OPTIONS] [SERVER] COMPTES GITHUB PRIVÉS ET MODULES NPM Docker exécute ses builds à l’intérieur d’un sandbox et cet environnement sandbox n’a pas accès à des informations telles que les clés ssh ou les informations d’identification npm. Pour contourner cette contrainte, quelques options recommandées sont disponibles pour les développeurs: Stocker les clés et les informations d’identification sur le système CI / CD. Les problèmes de sécurité d’avoir des informations d’identification sensibles à l’intérieur de la construction Docker peuvent être évités entièrement en ne les mettant jamais là en premier lieu. Au lieu de cela, stockez-les et récupérez-les dans le système CI / CD de votre infrastructure, et copiez manuellement les dépendances privées dans l’image. Utilisez un serveur npm interne. À l’aide d’un outil comme Verdaccio, configurez un proxy npm qui garde le flux des modules internes et des informations d’ identification privées . SOYEZ EXPLICITE AVEC LES TAGS Les balises aident à différencier les différentes versions d’images. Les balises peuvent être utilisées pour identifier les builds, les équipes qui travaillent sur l’image et littéralement toute autre désignation utile à une organisation pour gérer le développement des images. Si aucune balise n’est ajoutée explicitement, Docker assignera une balise par défaut à latest après la docker build. En tant que tag, le développement est le latest en date, mais peut être très problématique dans les environnements de production et de mise en scène. Pour éviter les problèmes latest , soyez explicites avec vos balises de construction. Voici un exemple de script attribuant des balises avec des variables d’environnement pour le git sha, le nom de la branche et le numéro de build de la construction, tous les trois pouvant être très utiles dans la gestion des versions, du débogage et du déploiement:  En savoir plus sur le marquage ici. Conteneurs et gestion des processus Les conteneurs sont conçus pour être légers et bien adaptés au niveau du processus, ce qui contribue à simplifier la gestion des processus: si le processus se termine, le conteneur se ferme. Cependant, cette cartographie 1:1 est une idéalisation qui n’est pas toujours maintenue dans la pratique. Comme les conteneurs Docker ne sont pas fournis avec un gestionnaire de processus, ajoutez un outil pour une gestion simple des processus. dumb-init de Yelp est un superviseur de processus simple et léger et un système d’initialisation conçu pour fonctionner en tant que PID 1 dans des environnements de conteneur. Cette désignation PID 1 pour le processus dumb-init est normalement affectée à un conteneur Linux en cours d’exécution et possède ses propres idiosyncrasies de signalisation du noyau qui compliquent la gestion des processus. Dumb-init fournit un niveau d’abstraction qui lui permet d’agir comme un proxy de signal, assurant le comportement attendu du processus. Ce qu’il faut inclure dans vos conteneurs d’applications Le principal avantage des conteneurs est qu’ils ne fournissent que ce qui est nécessaire. Gardez cela à l’esprit lorsque vous ajoutez des calques à vos images. Voici une liste de contrôle à inclure lors de la création d’images de conteneur: Votre code d’application et ses dépendances. Variables d’environnement nécessaires. Un proxy de signal simple pour la gestion de processus, comme dumb-init.\nC’est tout. Conclusion Les conteneurs sont une solution de virtualisation moderne mieux adaptée aux infrastructures nécessitant un partage efficace des ressources, des délais de démarrage rapides et une mise à l’échelle rapide. Les organisations DevOps utilisent des conteneurs d’applications pour implémenter ‘l’infrastructure en tant que code’, des équipes développant des microservices et s’appuyant sur des architectures distribuées et des groupes d’assurance qualité (QA) tirant parti de stratégies telles que les tests A/B et les déploiements incrémentaux en production. Tout comme l’approche recommandée pour Node.js monothread est 1 processus: 1 application, la meilleure pratique pour les conteneurs d’applications est 1 processus: 1 conteneur. Cette relation en miroir fait sans doute de Node.js l’environnement d’exécution le plus approprié pour le développement de conteneurs. Docker est une plate-forme ouverte pour le développement, l’expédition et l’exécution d’applications conteneurisées. Docker vous permet de séparer vos applications de votre infrastructure afin de pouvoir livrer des logiciels rapidement. Lorsque vous utilisez Docker avec Node.js, gardez à l’esprit: Ne lancez pas l’application en tant que root Cache node_modules Utilisez votre système CI / CD ou un serveur interne pour conserver les informations d’identification sensibles hors de l’image du conteneur Soyez explicite avec les balises de construction Gardez les récipients légers !","timeToRead":14,"frontmatter":{"title":"Conteneuriser des applications Node.js avec Docker","subtitle":"La légèreté et la reproductibilité des conteneurs en ont fait une option de plus en plus utilisée par les entreprises souhaitant développer des applications logicielles évolutives, hautement disponibles et contrôlées par les versions.","tags":["Docker","Node.js","Javascript","DevOps"],"date":"2018-05-11T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAAB01MmaaUEf//EABkQAAIDAQAAAAAAAAAAAAAAAAECABETEv/aAAgBAQABBQIuKDct1cwW8ReQn//EABcRAQADAAAAAAAAAAAAAAAAAAACERL/2gAIAQMBAT8BqLL/xAAYEQACAwAAAAAAAAAAAAAAAAAAAQIREv/aAAgBAgEBPwFuVmmf/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQMSFBYf/aAAgBAQAGPwLsYNlstn//xAAaEAEAAwADAAAAAAAAAAAAAAABABEhgbHx/9oACAEBAAE/IcACCRgtUqAWHkxa23U9Sf/aAAwDAQACAAMAAAAQtP8A/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARUf/aAAgBAwEBPxAAxkdv/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERMVH/2gAIAQIBAT8QYkqFgf/EABwQAQADAAIDAAAAAAAAAAAAAAEAESFBcTGRsf/aAAgBAQABPxA9p8EzIu7rChBd+Q3XwtSb7+wiB2HEr0inD1H/2Q==","aspectRatio":1.5337423312883436,"src":"/static/aa737b43d3d846778b615068a6705bf0/883ab/container.jpg","srcSet":"/static/aa737b43d3d846778b615068a6705bf0/f8f18/container.jpg 930w,\n/static/aa737b43d3d846778b615068a6705bf0/0e6ff/container.jpg 1860w,\n/static/aa737b43d3d846778b615068a6705bf0/883ab/container.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/docker-nodejs/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"authorId":"ludo","limit":9,"skip":27,"numPages":4,"currentPage":4}}}