{"componentChunkName":"component---src-templates-post-tsx","path":"/git-husky/","webpackCompilationHash":"ba1a271305926245155b","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQY023PvUrDUBTA8ZuCtoMoOLQ4dWhN14x2kEKXFkGoohQ/QBexOHRycAidKkgHHRq69APRoTjFJYODIA6+gSBYfYMmfYLE/5VT6NALP845NyeHc9UoCHZRQvonCLKKE4ZhAXYURTsYoE9dIy5iCzfUJnEdV+RF4iu6ikFH2EPxazzOcJmg4Rnn5C8ysIEOHqTe5/sT3qXOwYOtRr5/wLAqzpCTDXu4p2ETtyjgGJ/cX+se8jeU9fa4RBt5vWENpjzdkoGPcGg4RQsbOMEFmnBRRwVDHEK/yFXfvr/CoPjvZLKcdByDyzWGeajigzorGy0oOeRJiUtITe/pX1XzDk3buIMltSFR/zTtic3060X+8z8PsEUt8G3LVQAAAABJRU5ErkJggg==","width":400,"height":128,"src":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png","srcSet":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png 1x"}}},"markdownRemark":{"html":"<p>Dans cet article, vous apprendrez à créer et à gérer facilement des git hooks pour vos projets Node/NPM à l’aide de Husky.</p>\n<h2>Git Hooks</h2>\n<p>En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent. Des crochets (hooks) côté client sont déclenchés pour des actions telles que le commit ou le merge. Les crochets côté serveur s’exécutent dans des situations telles que la réception de données (<code>git push</code>) du client.</p>\n<p>Les hooks peuvent exécuter n’importe quelle logique personnalisée et, plus important encore, rejeter l’action effectuée si quelque chose ne va pas. Par exemple, vous pouvez annuler la validation du commit si son message ne contient pas l’ID de problème du suivi des problèmes. Vous pouvez également le refuser si l’analyse de code statique échoue. Cela peut être très utile si vous voulez vous assurer que votre base de code reste propre ou si vous souhaitez appliquer certaines règles de qualité.</p>\n<p>Mais comment pouvez-vous réellement installer et gérer ces hooks? Chaque fois que vous clonez un repo git, toutes les données git de votre projet sont stockées dans un répertoire <code>.git</code> dans votre dossier. Il contient plusieurs fichiers et sous-répertoires, l’un d’eux étant appelé <code>\u001dhooks</code>\u001d. À l’intérieur, vous trouverez un tas de fichiers.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1170px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7fb95d529b6827b77db65603da882cba/86d18/githooks.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41.02564102564102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABYklEQVQoz1WSWXLCQAxEff8bYS5A8hWoEMA2ixfwvoA3bEN11MpSyYdqXCNN67Vkw7IsXC4XZHmOXCLLMqQSZVkijmPs93vYto0oilDIHe9Zz+A37/0gQFEUGobtODDnc+x2O2y2W6xWKwRS0N/v6LpOv0N5xPN6u2GcJgzDgDhJVLSqKgTnswKN4wjDOezx8vqqyePppJFIMQv7vleCJE31rJvmV/Am4rkQsQnFq+v1S/BwPGKxWMB1XbVGYhY+nk8lJB2tM/4KkoiNKBxJjgAq+LHdYGbOdFa0S8FOyAZJtm2rjWjJ9/1/lu8SqQhybsxx9ip48ly8LZdq05NEGIZKNz0eKswFkZiPGxLKIwo20oxUt7pWWpISwtjKMkzTVLvv6zUcITzLPLlxWvY8TwkZfDR9E9YiRAhumoSsJ70RJzEs29LBcl60ySAdN01LpZDwl2mlwQ8hT4qSmqKcLwk/AQF3V7IELSymAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n        <source\n          srcset=\"/static/7fb95d529b6827b77db65603da882cba/8ffb1/githooks.webp 293w,\n/static/7fb95d529b6827b77db65603da882cba/17bf8/githooks.webp 585w,\n/static/7fb95d529b6827b77db65603da882cba/e2c1c/githooks.webp 1170w,\n/static/7fb95d529b6827b77db65603da882cba/0dcfc/githooks.webp 1248w\"\n          sizes=\"(max-width: 1170px) 100vw, 1170px\"\n          type=\"image/webp\"\n        />\n        <source\n          srcset=\"/static/7fb95d529b6827b77db65603da882cba/f93ee/githooks.png 293w,\n/static/7fb95d529b6827b77db65603da882cba/8c0a8/githooks.png 585w,\n/static/7fb95d529b6827b77db65603da882cba/e1668/githooks.png 1170w,\n/static/7fb95d529b6827b77db65603da882cba/86d18/githooks.png 1248w\"\n          sizes=\"(max-width: 1170px) 100vw, 1170px\"\n          type=\"image/png\"\n        />\n        <img\n          class=\"gatsby-resp-image-image\"\n          src=\"/static/7fb95d529b6827b77db65603da882cba/e1668/githooks.png\"\n          alt=\"Répertoire Git Hooks\"\n          title=\"Répertoire Git Hooks\"\n        />\n      </picture>\n  </a>\n    </span></p>\n<p>Chacun d’entre eux est un script, qui est exécuté lorsqu’un événement spécifique se produit. Le nom de l’événement correspond au nom du fichier. Par exemple, la <code>\u001dpre-commit</code>\u001d est exécutée avant de commiter vos modifications.</p>\n<p>Comme vous pouvez le constater, tous les fichiers ont une extension <code>\u001d.sample</code>\u001d. Git ignore ces fichiers à moins que vous ne les renommiez. Vous devez supprimer l’extension <code>\u001d.sample</code>\u001d pour activer ces hooks. Dans les exemples de fichiers, vous pouvez trouver une description et un exemple d’implémentation que vous pouvez utiliser comme point de départ pour implémenter vos propres hooks.</p>\n<h2>À quoi ça sert?</h2>\n<p>Maintenant, regardons quelques exemples spécifiques de ce qui peut être réalisé avec les git hooks. Comme ce ne sont que des scripts, vous pouvez faire à peu près n’importe quoi. Habituellement, cela signifie effectuer divers contrôles de qualité.</p>\n<p>Vous pouvez vous assurer que l’utilisateur a son nom et son email renseignés. Vous pouvez vérifier que le message de validation est correctement formaté. Vous pouvez essayer de créer votre application et rejeter le commit si la construction échoue. Vous pouvez exécuter des tests pour vous assurer qu’ils passent avant le commit.</p>\n<p>L’utilisation typique est également l’analyse de code statique ou le formatage. Cela signifie qu’il faut vérifier dans votre code les problèmes courants, les mauvaises pratiques, les conventions de dénomination, etc. Il peut également être utile d’exécuter un outil tel que Prettier pour s’assurer que le code est bien formaté avant le commit. Cela évite de nombreux maux de tête lors de la révision du code. Vous pouvez même vérifier les failles de sécurité de votre code avec un outil tel que Snyk.</p>\n<h2>Distribution aux membres de l’équipe</h2>\n<p>Avec les hooks côté serveur, la distribution est facile. Vous n’avez généralement qu’un seul référentiel de serveur principal. Cela signifie que tous les membres de l’équipe mettent généralement leurs modifications au même endroit. Vous y installez vos hooks et vous avez terminé.</p>\n<p>Avec les hooks côté client, cela devient plus compliqué. Lorsque vous clonez un référentiel, les hooks ne sont pas transférés au client. Cela signifie qu’un référentiel fraîchement cloné n’a aucun hook, peu importe le type de hook que vous avez sur le serveur. Si vous voulez que les membres de votre équipe aient un ensemble unifié de git hooks, vous devez les distribuer d’une manière ou d’une autre et vous assurer qu’ils sont inclus dans leur sous-répertoire git hooks.</p>\n<p>La solution la plus élémentaire consiste à créer un emplacement partagé, où vous stockez vos hooks, puis demandez à vos développeurs de les télécharger et de les mettre dans leur répertoire de hooks. Bien sûr, vous ne pouvez pas être sûr qu’ils le feront réellement. Le problème est qu’ils ont besoin de savoir qu’ils devraient le faire et comment. Et même s’ils le font, ils peuvent être paresseux ou simplement ignorer votre politique.</p>\n<p>Vous pouvez améliorer un peu cette solution de base en ayant des hooks dans le référentiel de votre projet et en laissant simplement à vos développeurs exécuter un script personnalisé <a href=\"https://gist.github.com/tilap/0590e78c9cfd8f6548f5\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">comme celui-ci</a>, qui les copie ensuite dans leur répertoire de hooks. Sinon, git propose une option pour changer la destination du répertoire des hooks en un emplacement personnalisé:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">git</span> config core.hooksPath YOUR_DIRECTORY</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Ces solutions facilitent la distribution, mais ne résolvent pas les problèmes essentiels.</p>\n<h2>Husky</h2>\n<h3>Installation</h3>\n<p>Vous pouvez installer <a href=\"https://github.com/typicode/husky\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Husky</a> simplement en exécutant:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> husky --save-dev</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Alternative, avec yarn:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> husky --dev</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h3>Ajout de hooks</h3>\n<p>Ajouter des hooks avec Husky est facile. Vous devez juste éditer votre <code>package.json</code>. Vous définissez quels scripts doivent être exécutés sur quel événement git.</p>\n<p>Pour Husky 1.0.0+, utilisez:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"husky\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"pre-commit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm test\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"pre-push\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm test\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token property\">\"...\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"...\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Si vous utilisez une version de Husky antérieure à 1.0.0 (disponible dans la version candidate du 06/2018), la syntaxe est légèrement différente. Vous ajoutez vos hooks Husky directement dans la section scripts.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"precommit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm test\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"prepush\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"npm test\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"...\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"...\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>L’exemple ci-dessus exécute tous vos tests avant de commiter et avant de pousser et si vos tests échouent, l’action git n’est pas exécutée. Bien sûr, vous pouvez exécuter tout autre script nom plutôt que le <code>nom test</code>.</p>\n<h3>Problème de correction automatique avant validation</h3>\n<p>Il est utile de casser le build si quelque chose ne va pas, mais il est encore plus utile de corriger automatiquement les problèmes avant de s’engager. Par exemple, vous pouvez personnaliser votre code en utilisant <a href=\"https://prettier.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Prettier</a> avant de faire un commit ou vous pouvez corriger automatiquement les problèmes de formatage, qui peuvent être résolus automatiquement. C’est beaucoup plus facile de cette façon.</p>\n<p>Heureusement, il existe un outil pour cela. Cela s’appelle <a href=\"https://github.com/okonet/lint-staged\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">lint-staged</a>. Vous pouvez l’installer par:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">npm</span> installer --save-dev lint-staged</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Maintenant, sur votre action de pre-commit, vous exécutez directement <code>\u001dlint-staged</code>\u001d au lieu de votre linter. Dans <code>lint-staged</code>, vous définissez ce qui doit être exécuté:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"husky\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"pre-commit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"lint-staged\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"lint-staged\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"*.js\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"eslint --fix\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"git add\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Lorsque vous essayez de commiter maintenant, <code>\u001dlint-staged</code>\u001d peut modifier vos fichiers avant l’exécution de la validation. Cependant, ce qui est vraiment bien, c’est que vous ne filtrez que les fichiers en attente de validation, et non l’ensemble de votre projet. Cela signifie que l’ensemble du processus est beaucoup plus rapide.</p>\n<h2>Bug JetBrains IDE</h2>\n<p>La bonne nouvelle est que les git hooks configurés de cette manière sont exécutés non seulement lorsque vous utilisez git à partir de votre terminal, mais également à partir d’un IDE. La mauvaise nouvelle est que les IDE JetBrains (IDEA, Webstorm, …) ont actuellement un <a href=\"https://github.com/okonet/lint-staged/issues/151\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">méchant bogue</a> (voir <a href=\"https://youtrack.jetbrains.com/issue/IDEA-135454\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">IDEA-135454</a>) et ne fonctionnent pas bien avec cette configuration.</p>\n<p>Le problème n’est pas résolu avant plusieurs années, mais heureusement, il existe une solution de contournement. Vous devez juste ajouter ce hook post-commit:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-json line-numbers\"><code class=\"language-json\"><span class=\"token property\">\"post-commit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"git update-index -g\"</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Bien entendu, il ne s’agit que d’une solution de contournement jusqu’à ce que le problème soit résolu. Le suivi des problèmes de JetBrains contient une fonctionnalité de vote, alors assurez-vous de voter pour que ce problème soit résolu s’il vous pose problème.</p>\n<h2>Intégration continue</h2>\n<p>Une chose à noter est que Husky installe les hooks uniquement lorsqu’il ne s’exécute pas sur un serveur d’intégration continue. Husky <a href=\"https://github.com/watson/is-ci\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">peut détecter</a> qu’il est en cours d’exécution dans le cadre d’un travail CI et n’installe aucun hook.</p>\n<h2>En ignorant</h2>\n<p>Les hooks côté client peuvent être utiles, mais vous ne pouvez pas trop compter sur eux. Ils ne sont que le premier niveau de défense. Vous ne pouvez pas être sûr à 100% qu’ils soient exécutés. Ils peuvent être ignorés à la demande en ajoutant une option de ligne de commande:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-bash line-numbers\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit --no-verify</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>Pour rendre les choses encore plus faciles, les hooks peuvent être désactivés à l’aide de certaines variables environnementales. Pour cette raison, il est toujours utile d’appliquer la même fonctionnalité sur le serveur.</p>\n<h2>Performance</h2>\n<p>Bien que les hooks cotés client tels que le pre-commit puissent s’avérer très utiles, vous devez garder à l’esprit qu’ils prennent un certain temps à s’exécuter. Les commits, qui sont généralement très rapides, car ils ne se produisent que sur le client, peuvent prendre soudainement très longtemps. Vous serez peut-être tenté d’exécuter tous les tests, l’analyse de code statique, les vérifications préalables, etc., avant chaque validation. Lorsqu’un commit prend des années, vos développeurs ne seront pas heureux et seront tentés d’ignorer les hooks lors de l’exécution de leurs commandes git. Vous devez donc trouver le bon équilibre entre ce qui doit être effectué sur le client et ce qui peut être un point d’accès côté serveur.</p>\n<h2>Conclusion</h2>\n<p>Husky est un outil utile qui permet de créer et de gérer facilement des hooks git sur le client. Vous n’avez plus besoin de distribuer vos hooks manuellement. Comme pour tout, gardez le nombre de hooks côté client avec modération afin d’éviter les temps d’exécution trop longs.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dans cet article, vous apprendrez à créer et à gérer facilement des git hooks pour vos projets Node/NPM à l’aide de Husky."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Git Hooks"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent. Des crochets (hooks) côté client sont déclenchés pour des actions telles que le commit ou le merge. Les crochets côté serveur s’exécutent dans des situations telles que la réception de données ("},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git push"}]},{"type":"text","value":") du client."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Les hooks peuvent exécuter n’importe quelle logique personnalisée et, plus important encore, rejeter l’action effectuée si quelque chose ne va pas. Par exemple, vous pouvez annuler la validation du commit si son message ne contient pas l’ID de problème du suivi des problèmes. Vous pouvez également le refuser si l’analyse de code statique échoue. Cela peut être très utile si vous voulez vous assurer que votre base de code reste propre ou si vous souhaitez appliquer certaines règles de qualité."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Mais comment pouvez-vous réellement installer et gérer ces hooks? Chaque fois que vous clonez un repo git, toutes les données git de votre projet sont stockées dans un répertoire "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".git"}]},{"type":"text","value":" dans votre dossier. Il contient plusieurs fichiers et sous-répertoires, l’un d’eux étant appelé "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001dhooks"}]},{"type":"text","value":"\u001d. À l’intérieur, vous trouverez un tas de fichiers."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-wrapper"],"style":"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1170px;"},"children":[{"type":"text","value":"\n      "},{"type":"element","tagName":"a","properties":{"className":["gatsby-resp-image-link"],"href":"/static/7fb95d529b6827b77db65603da882cba/86d18/githooks.png","style":"display: block","target":"_blank","rel":["noopener"]},"children":[{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["gatsby-resp-image-background-image"],"style":"padding-bottom: 41.02564102564102%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABYklEQVQoz1WSWXLCQAxEff8bYS5A8hWoEMA2ixfwvoA3bEN11MpSyYdqXCNN67Vkw7IsXC4XZHmOXCLLMqQSZVkijmPs93vYto0oilDIHe9Zz+A37/0gQFEUGobtODDnc+x2O2y2W6xWKwRS0N/v6LpOv0N5xPN6u2GcJgzDgDhJVLSqKgTnswKN4wjDOezx8vqqyePppJFIMQv7vleCJE31rJvmV/Am4rkQsQnFq+v1S/BwPGKxWMB1XbVGYhY+nk8lJB2tM/4KkoiNKBxJjgAq+LHdYGbOdFa0S8FOyAZJtm2rjWjJ9/1/lu8SqQhybsxx9ip48ly8LZdq05NEGIZKNz0eKswFkZiPGxLKIwo20oxUt7pWWpISwtjKMkzTVLvv6zUcITzLPLlxWvY8TwkZfDR9E9YiRAhumoSsJ70RJzEs29LBcl60ySAdN01LpZDwl2mlwQ8hT4qSmqKcLwk/AQF3V7IELSymAAAAAElFTkSuQmCC'); background-size: cover; display: block;"},"children":[]},{"type":"text","value":"\n  "},{"type":"element","tagName":"picture","properties":{},"children":[{"type":"text","value":"\n        "},{"type":"element","tagName":"source","properties":{"srcSet":["/static/7fb95d529b6827b77db65603da882cba/8ffb1/githooks.webp 293w","/static/7fb95d529b6827b77db65603da882cba/17bf8/githooks.webp 585w","/static/7fb95d529b6827b77db65603da882cba/e2c1c/githooks.webp 1170w","/static/7fb95d529b6827b77db65603da882cba/0dcfc/githooks.webp 1248w"],"sizes":["(max-width:","1170px)","100vw,","1170px"],"type":"image/webp"},"children":[]},{"type":"text","value":"\n        "},{"type":"element","tagName":"source","properties":{"srcSet":["/static/7fb95d529b6827b77db65603da882cba/f93ee/githooks.png 293w","/static/7fb95d529b6827b77db65603da882cba/8c0a8/githooks.png 585w","/static/7fb95d529b6827b77db65603da882cba/e1668/githooks.png 1170w","/static/7fb95d529b6827b77db65603da882cba/86d18/githooks.png 1248w"],"sizes":["(max-width:","1170px)","100vw,","1170px"],"type":"image/png"},"children":[]},{"type":"text","value":"\n        "},{"type":"element","tagName":"img","properties":{"className":["gatsby-resp-image-image"],"src":"/static/7fb95d529b6827b77db65603da882cba/e1668/githooks.png","alt":"Répertoire Git Hooks","title":"Répertoire Git Hooks"},"children":[]},{"type":"text","value":"\n      "}]},{"type":"text","value":"\n  "}]},{"type":"text","value":"\n    "}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Chacun d’entre eux est un script, qui est exécuté lorsqu’un événement spécifique se produit. Le nom de l’événement correspond au nom du fichier. Par exemple, la "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001dpre-commit"}]},{"type":"text","value":"\u001d est exécutée avant de commiter vos modifications."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Comme vous pouvez le constater, tous les fichiers ont une extension "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001d.sample"}]},{"type":"text","value":"\u001d. Git ignore ces fichiers à moins que vous ne les renommiez. Vous devez supprimer l’extension "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001d.sample"}]},{"type":"text","value":"\u001d pour activer ces hooks. Dans les exemples de fichiers, vous pouvez trouver une description et un exemple d’implémentation que vous pouvez utiliser comme point de départ pour implémenter vos propres hooks."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"À quoi ça sert?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Maintenant, regardons quelques exemples spécifiques de ce qui peut être réalisé avec les git hooks. Comme ce ne sont que des scripts, vous pouvez faire à peu près n’importe quoi. Habituellement, cela signifie effectuer divers contrôles de qualité."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vous pouvez vous assurer que l’utilisateur a son nom et son email renseignés. Vous pouvez vérifier que le message de validation est correctement formaté. Vous pouvez essayer de créer votre application et rejeter le commit si la construction échoue. Vous pouvez exécuter des tests pour vous assurer qu’ils passent avant le commit."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"L’utilisation typique est également l’analyse de code statique ou le formatage. Cela signifie qu’il faut vérifier dans votre code les problèmes courants, les mauvaises pratiques, les conventions de dénomination, etc. Il peut également être utile d’exécuter un outil tel que Prettier pour s’assurer que le code est bien formaté avant le commit. Cela évite de nombreux maux de tête lors de la révision du code. Vous pouvez même vérifier les failles de sécurité de votre code avec un outil tel que Snyk."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Distribution aux membres de l’équipe"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Avec les hooks côté serveur, la distribution est facile. Vous n’avez généralement qu’un seul référentiel de serveur principal. Cela signifie que tous les membres de l’équipe mettent généralement leurs modifications au même endroit. Vous y installez vos hooks et vous avez terminé."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Avec les hooks côté client, cela devient plus compliqué. Lorsque vous clonez un référentiel, les hooks ne sont pas transférés au client. Cela signifie qu’un référentiel fraîchement cloné n’a aucun hook, peu importe le type de hook que vous avez sur le serveur. Si vous voulez que les membres de votre équipe aient un ensemble unifié de git hooks, vous devez les distribuer d’une manière ou d’une autre et vous assurer qu’ils sont inclus dans leur sous-répertoire git hooks."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La solution la plus élémentaire consiste à créer un emplacement partagé, où vous stockez vos hooks, puis demandez à vos développeurs de les télécharger et de les mettre dans leur répertoire de hooks. Bien sûr, vous ne pouvez pas être sûr qu’ils le feront réellement. Le problème est qu’ils ont besoin de savoir qu’ils devraient le faire et comment. Et même s’ils le font, ils peuvent être paresseux ou simplement ignorer votre politique."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vous pouvez améliorer un peu cette solution de base en ayant des hooks dans le référentiel de votre projet et en laissant simplement à vos développeurs exécuter un script personnalisé "},{"type":"element","tagName":"a","properties":{"href":"https://gist.github.com/tilap/0590e78c9cfd8f6548f5","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"comme celui-ci"}]},{"type":"text","value":", qui les copie ensuite dans leur répertoire de hooks. Sinon, git propose une option pour changer la destination du répertoire des hooks en un emplacement personnalisé:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"bash"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-bash","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-bash"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"git"}]},{"type":"text","value":" config core.hooksPath YOUR_DIRECTORY"}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ces solutions facilitent la distribution, mais ne résolvent pas les problèmes essentiels."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Husky"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Installation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Vous pouvez installer "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/typicode/husky","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"Husky"}]},{"type":"text","value":" simplement en exécutant:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"bash"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-bash","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-bash"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"npm"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"install"}]},{"type":"text","value":" husky --save-dev"}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Alternative, avec yarn:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"bash"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-bash","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-bash"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"yarn"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"add"}]},{"type":"text","value":" husky --dev"}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Ajout de hooks"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ajouter des hooks avec Husky est facile. Vous devez juste éditer votre "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"package.json"}]},{"type":"text","value":". Vous définissez quels scripts doivent être exécutés sur quel événement git."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pour Husky 1.0.0+, utilisez:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"json"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-json","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-json"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"husky\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"hooks\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"pre-commit\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"npm test\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"pre-push\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"npm test\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"...\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"...\""}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Si vous utilisez une version de Husky antérieure à 1.0.0 (disponible dans la version candidate du 06/2018), la syntaxe est légèrement différente. Vous ajoutez vos hooks Husky directement dans la section scripts."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"json"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-json","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-json"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"scripts\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"precommit\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"npm test\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"prepush\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"npm test\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"...\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"...\""}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"L’exemple ci-dessus exécute tous vos tests avant de commiter et avant de pousser et si vos tests échouent, l’action git n’est pas exécutée. Bien sûr, vous pouvez exécuter tout autre script nom plutôt que le "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"nom test"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Problème de correction automatique avant validation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Il est utile de casser le build si quelque chose ne va pas, mais il est encore plus utile de corriger automatiquement les problèmes avant de s’engager. Par exemple, vous pouvez personnaliser votre code en utilisant "},{"type":"element","tagName":"a","properties":{"href":"https://prettier.io/","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"Prettier"}]},{"type":"text","value":" avant de faire un commit ou vous pouvez corriger automatiquement les problèmes de formatage, qui peuvent être résolus automatiquement. C’est beaucoup plus facile de cette façon."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Heureusement, il existe un outil pour cela. Cela s’appelle "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/okonet/lint-staged","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"lint-staged"}]},{"type":"text","value":". Vous pouvez l’installer par:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"bash"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-bash","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-bash"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"npm"}]},{"type":"text","value":" installer --save-dev lint-staged"}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Maintenant, sur votre action de pre-commit, vous exécutez directement "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001dlint-staged"}]},{"type":"text","value":"\u001d au lieu de votre linter. Dans "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"lint-staged"}]},{"type":"text","value":", vous définissez ce qui doit être exécuté:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"json"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-json","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-json"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"husky\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"hooks\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n      "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"pre-commit\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"lint-staged\""}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"lint-staged\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"*.js\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"["}]},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"eslint --fix\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"git add\""}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"]"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]},{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lorsque vous essayez de commiter maintenant, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"\u001dlint-staged"}]},{"type":"text","value":"\u001d peut modifier vos fichiers avant l’exécution de la validation. Cependant, ce qui est vraiment bien, c’est que vous ne filtrez que les fichiers en attente de validation, et non l’ensemble de votre projet. Cela signifie que l’ensemble du processus est beaucoup plus rapide."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Bug JetBrains IDE"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La bonne nouvelle est que les git hooks configurés de cette manière sont exécutés non seulement lorsque vous utilisez git à partir de votre terminal, mais également à partir d’un IDE. La mauvaise nouvelle est que les IDE JetBrains (IDEA, Webstorm, …) ont actuellement un "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/okonet/lint-staged/issues/151","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"méchant bogue"}]},{"type":"text","value":" (voir "},{"type":"element","tagName":"a","properties":{"href":"https://youtrack.jetbrains.com/issue/IDEA-135454","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"IDEA-135454"}]},{"type":"text","value":") et ne fonctionnent pas bien avec cette configuration."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Le problème n’est pas résolu avant plusieurs années, mais heureusement, il existe une solution de contournement. Vous devez juste ajouter ce hook post-commit:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"json"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-json","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-json"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"\"post-commit\""}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"\"git update-index -g\""}]}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bien entendu, il ne s’agit que d’une solution de contournement jusqu’à ce que le problème soit résolu. Le suivi des problèmes de JetBrains contient une fonctionnalité de vote, alors assurez-vous de voter pour que ce problème soit résolu s’il vous pose problème."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Intégration continue"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Une chose à noter est que Husky installe les hooks uniquement lorsqu’il ne s’exécute pas sur un serveur d’intégration continue. Husky "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/watson/is-ci","target":"_blank","rel":["nofollow","noopener","noreferrer"]},"children":[{"type":"text","value":"peut détecter"}]},{"type":"text","value":" qu’il est en cours d’exécution dans le cadre d’un travail CI et n’installe aucun hook."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"En ignorant"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Les hooks côté client peuvent être utiles, mais vous ne pouvez pas trop compter sur eux. Ils ne sont que le premier niveau de défense. Vous ne pouvez pas être sûr à 100% qu’ils soient exécutés. Ils peuvent être ignorés à la demande en ajoutant une option de ligne de commande:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"bash"},"children":[{"type":"element","tagName":"pre","properties":{"style":"counter-reset: linenumber NaN","className":["language-bash","line-numbers"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-bash"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"git"}]},{"type":"text","value":" commit --no-verify"}]},{"type":"element","tagName":"span","properties":{"ariaHidden":"true","className":["line-numbers-rows"],"style":"white-space: normal; width: auto; left: 0;"},"children":[{"type":"element","tagName":"span","properties":{},"children":[]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pour rendre les choses encore plus faciles, les hooks peuvent être désactivés à l’aide de certaines variables environnementales. Pour cette raison, il est toujours utile d’appliquer la même fonctionnalité sur le serveur."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Performance"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Bien que les hooks cotés client tels que le pre-commit puissent s’avérer très utiles, vous devez garder à l’esprit qu’ils prennent un certain temps à s’exécuter. Les commits, qui sont généralement très rapides, car ils ne se produisent que sur le client, peuvent prendre soudainement très longtemps. Vous serez peut-être tenté d’exécuter tous les tests, l’analyse de code statique, les vérifications préalables, etc., avant chaque validation. Lorsqu’un commit prend des années, vos développeurs ne seront pas heureux et seront tentés d’ignorer les hooks lors de l’exécution de leurs commandes git. Vous devez donc trouver le bon équilibre entre ce qui doit être effectué sur le client et ce qui peut être un point d’accès côté serveur."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Conclusion"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Husky est un outil utile qui permet de créer et de gérer facilement des hooks git sur le client. Vous n’avez plus besoin de distribuer vos hooks manuellement. Comme pour tout, gardez le nombre de hooks côté client avec modération afin d’éviter les temps d’exécution trop longs."}]}],"data":{"quirksMode":false}},"excerpt":"Dans cet article, vous apprendrez à créer et à gérer facilement des git hooks pour vos projets Node/NPM à l’aide de Husky. Git Hooks En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent. Des crochets (hooks) côté client sont déclenchés pour des actions telles que le commit ou le merge. Les crochets côté serveur s’exécutent dans des situations telles que la réception de données (git push) du client. Les hooks peuvent exécuter n’importe quelle logique personnalisée et, plus important encore, rejeter l’action effectuée si quelque chose ne va pas. Par exemple, vous pouvez annuler la validation du commit si son message ne contient pas l’ID de problème du suivi des problèmes. Vous pouvez également le refuser si l’analyse de code statique échoue. Cela peut être très utile si vous voulez vous assurer que votre base de code reste propre ou si vous souhaitez appliquer certaines règles de qualité. Mais comment pouvez-vous réellement installer et gérer ces hooks? Chaque fois que vous clonez un repo git, toutes les données git de votre projet sont stockées dans un répertoire .git dans votre dossier. Il contient plusieurs fichiers et sous-répertoires, l’un d’eux étant appelé \u001dhooks\u001d. À l’intérieur, vous trouverez un tas de fichiers.  Chacun d’entre eux est un script, qui est exécuté lorsqu’un événement spécifique se produit. Le nom de l’événement correspond au nom du fichier. Par exemple, la \u001dpre-commit\u001d est exécutée avant de commiter vos modifications. Comme vous pouvez le constater, tous les fichiers ont une extension \u001d.sample\u001d. Git ignore ces fichiers à moins que vous ne les renommiez. Vous devez supprimer l’extension \u001d.sample\u001d pour activer ces hooks. Dans les exemples de fichiers, vous pouvez trouver une description et un exemple d’implémentation que vous pouvez utiliser comme point de départ pour implémenter vos propres hooks. À quoi ça sert? Maintenant, regardons quelques exemples spécifiques de ce qui peut être réalisé avec les git hooks. Comme ce ne sont que des scripts, vous pouvez faire à peu près n’importe quoi. Habituellement, cela signifie effectuer divers contrôles de qualité. Vous pouvez vous assurer que l’utilisateur a son nom et son email renseignés. Vous pouvez vérifier que le message de validation est correctement formaté. Vous pouvez essayer de créer votre application et rejeter le commit si la construction échoue. Vous pouvez exécuter des tests pour vous assurer qu’ils passent avant le commit. L’utilisation typique est également l’analyse de code statique ou le formatage. Cela signifie qu’il faut vérifier dans votre code les problèmes courants, les mauvaises pratiques, les conventions de dénomination, etc. Il peut également être utile d’exécuter un outil tel que Prettier pour s’assurer que le code est bien formaté avant le commit. Cela évite de nombreux maux de tête lors de la révision du code. Vous pouvez même vérifier les failles de sécurité de votre code avec un outil tel que Snyk. Distribution aux membres de l’équipe Avec les hooks côté serveur, la distribution est facile. Vous n’avez généralement qu’un seul référentiel de serveur principal. Cela signifie que tous les membres de l’équipe mettent généralement leurs modifications au même endroit. Vous y installez vos hooks et vous avez terminé. Avec les hooks côté client, cela devient plus compliqué. Lorsque vous clonez un référentiel, les hooks ne sont pas transférés au client. Cela signifie qu’un référentiel fraîchement cloné n’a aucun hook, peu importe le type de hook que vous avez sur le serveur. Si vous voulez que les membres de votre équipe aient un ensemble unifié de git hooks, vous devez les distribuer d’une manière ou d’une autre et vous assurer qu’ils sont inclus dans leur sous-répertoire git hooks. La solution la plus élémentaire consiste à créer un emplacement partagé, où vous stockez vos hooks, puis demandez à vos développeurs de les télécharger et de les mettre dans leur répertoire de hooks. Bien sûr, vous ne pouvez pas être sûr qu’ils le feront réellement. Le problème est qu’ils ont besoin de savoir qu’ils devraient le faire et comment. Et même s’ils le font, ils peuvent être paresseux ou simplement ignorer votre politique. Vous pouvez améliorer un peu cette solution de base en ayant des hooks dans le référentiel de votre projet et en laissant simplement à vos développeurs exécuter un script personnalisé comme celui-ci, qui les copie ensuite dans leur répertoire de hooks. Sinon, git propose une option pour changer la destination du répertoire des hooks en un emplacement personnalisé: Ces solutions facilitent la distribution, mais ne résolvent pas les problèmes essentiels. Husky Installation Vous pouvez installer Husky simplement en exécutant: Alternative, avec yarn: Ajout de hooks Ajouter des hooks avec Husky est facile. Vous devez juste éditer votre package.json. Vous définissez quels scripts doivent être exécutés sur quel événement git. Pour Husky 1.0.0+, utilisez: Si vous utilisez une version de Husky antérieure à 1.0.0 (disponible dans la version candidate du 06/2018), la syntaxe est légèrement différente. Vous ajoutez vos hooks Husky directement dans la section scripts. L’exemple ci-dessus exécute tous vos tests avant de commiter et avant de pousser et si vos tests échouent, l’action git n’est pas exécutée. Bien sûr, vous pouvez exécuter tout autre script nom plutôt que le nom test. Problème de correction automatique avant validation Il est utile de casser le build si quelque chose ne va pas, mais il est encore plus utile de corriger automatiquement les problèmes avant de s’engager. Par exemple, vous pouvez personnaliser votre code en utilisant Prettier avant de faire un commit ou vous pouvez corriger automatiquement les problèmes de formatage, qui peuvent être résolus automatiquement. C’est beaucoup plus facile de cette façon. Heureusement, il existe un outil pour cela. Cela s’appelle lint-staged. Vous pouvez l’installer par: Maintenant, sur votre action de pre-commit, vous exécutez directement \u001dlint-staged\u001d au lieu de votre linter. Dans lint-staged, vous définissez ce qui doit être exécuté: Lorsque vous essayez de commiter maintenant, \u001dlint-staged\u001d peut modifier vos fichiers avant l’exécution de la validation. Cependant, ce qui est vraiment bien, c’est que vous ne filtrez que les fichiers en attente de validation, et non l’ensemble de votre projet. Cela signifie que l’ensemble du processus est beaucoup plus rapide. Bug JetBrains IDE La bonne nouvelle est que les git hooks configurés de cette manière sont exécutés non seulement lorsque vous utilisez git à partir de votre terminal, mais également à partir d’un IDE. La mauvaise nouvelle est que les IDE JetBrains (IDEA, Webstorm, …) ont actuellement un méchant bogue (voir IDEA-135454) et ne fonctionnent pas bien avec cette configuration. Le problème n’est pas résolu avant plusieurs années, mais heureusement, il existe une solution de contournement. Vous devez juste ajouter ce hook post-commit: Bien entendu, il ne s’agit que d’une solution de contournement jusqu’à ce que le problème soit résolu. Le suivi des problèmes de JetBrains contient une fonctionnalité de vote, alors assurez-vous de voter pour que ce problème soit résolu s’il vous pose problème. Intégration continue Une chose à noter est que Husky installe les hooks uniquement lorsqu’il ne s’exécute pas sur un serveur d’intégration continue. Husky peut détecter qu’il est en cours d’exécution dans le cadre d’un travail CI et n’installe aucun hook. En ignorant Les hooks côté client peuvent être utiles, mais vous ne pouvez pas trop compter sur eux. Ils ne sont que le premier niveau de défense. Vous ne pouvez pas être sûr à 100% qu’ils soient exécutés. Ils peuvent être ignorés à la demande en ajoutant une option de ligne de commande: Pour rendre les choses encore plus faciles, les hooks peuvent être désactivés à l’aide de certaines variables environnementales. Pour cette raison, il est toujours utile d’appliquer la même fonctionnalité sur le serveur. Performance Bien que les hooks cotés client tels que le pre-commit puissent s’avérer très utiles, vous devez garder à l’esprit qu’ils prennent un certain temps à s’exécuter. Les commits, qui sont généralement très rapides, car ils ne se produisent que sur le client, peuvent prendre soudainement très longtemps. Vous serez peut-être tenté d’exécuter tous les tests, l’analyse de code statique, les vérifications préalables, etc., avant chaque validation. Lorsqu’un commit prend des années, vos développeurs ne seront pas heureux et seront tentés d’ignorer les hooks lors de l’exécution de leurs commandes git. Vous devez donc trouver le bon équilibre entre ce qui doit être effectué sur le client et ce qui peut être un point d’accès côté serveur. Conclusion Husky est un outil utile qui permet de créer et de gérer facilement des hooks git sur le client. Vous n’avez plus besoin de distribuer vos hooks manuellement. Comme pour tout, gardez le nombre de hooks côté client avec modération afin d’éviter les temps d’exécution trop longs.","timeToRead":7,"frontmatter":{"title":"Git hooks avec Husky","subtitle":"En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent.","userDate":"25 November 2018","date":"2018-11-25T08:00:00.000Z","tags":["Git","Node.js","Javascript"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAQBAgMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAeZvaUrjYf/EABkQAQADAQEAAAAAAAAAAAAAAAEAAiEREv/aAAgBAQABBQIrr2z4jDGf/8QAFhEBAQEAAAAAAAAAAAAAAAAAABIB/9oACAEDAQE/AZxL/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8Bqv/EABkQAAIDAQAAAAAAAAAAAAAAAAAyASAxkf/aAAgBAQAGPwJTBZ7T/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERIUGh/9oACAEBAAE/IWy6ZuV4UVsOR8Kf/9oADAMBAAIAAwAAABDb7//EABcRAAMBAAAAAAAAAAAAAAAAAAABETH/2gAIAQMBAT8QbtIP/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/ELTT/8QAGxABAQEBAAMBAAAAAAAAAAAAAREAITFBUXH/2gAIAQEAAT8QEkQjOdxTGyQQ/nnNus/UZr6lPWsqdhrblLv/2Q==","aspectRatio":1.6103059581320451,"src":"/static/ac7733f363ac6c799dc4d94c21beb53b/883ab/husky2.jpg","srcSet":"/static/ac7733f363ac6c799dc4d94c21beb53b/f8f18/husky2.jpg 930w,\n/static/ac7733f363ac6c799dc4d94c21beb53b/0e6ff/husky2.jpg 1860w,\n/static/ac7733f363ac6c799dc4d94c21beb53b/883ab/husky2.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"ludo","name":"Wyffels Ludovic","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png 1x"}}]}}}},"relatedPosts":{"totalCount":3,"edges":[{"node":{"id":"a7b23c0d-9c79-54c7-8132-41d2f4632b4c","timeToRead":1,"excerpt":"Une des choses les plus grandes et les pires avec git est que vous pouvez réécrire l’histoire. Voici une façon sournoise d’abuser de cela, je ne peux pas penser à une raison légitime de le faire. Comme pour tout, merci StackOverflow pour toutes les options que je peux choisir parmi Fixe la date du dernier commit à la date du jour Fixer la date du dernier commit à une date arbitraire Définir la date d’une validation arbitraire sur une date arbitraire ou courante Rebaser avant ledit engagement et arrêter pour modification: git rebase <commit-hash>^ -i Remplace pick par e (edit) sur la ligne avec ce commit (le premier) Quittez l’éditeur (ESC suivi de :wq dans VIM) Non plus: GIT_COMMITTER_DATE=\"$(date)\" git commit --amend --no-edit --date \"$(date)\" GIT_COMMITTER_DATE=\"Mon 20 Aug 2018 20:19:19 BST\" git commit --amend --no-edit --date \"Mon 20 Aug 2018 20:19:19 BST\" Voir ici pour plus d’informations sur le rebase et l’édition dans git: Fractionner un commit git existant. Après l’une de ces 3 options, vous voudrez exécuter:","frontmatter":{"title":"Changer la date d'un commit","subtitle":"Une des choses les plus grandes et les pires avec git est que vous pouvez réécrire l'histoire. Voici une façon sournoise d'abuser de cela, je ne peux pas penser à une raison légitime de le faire."},"fields":{"slug":"/git-changeGitOfCommit/"}}},{"node":{"id":"335e1698-dc7c-51f5-94d1-dff1c8343c42","timeToRead":1,"excerpt":"L’une des principales différences entre git et les autres systèmes de contrôle de version est qu’il permet à l’utilisateur de réécrire l’historique. Pour ce faire, le moyen principal consiste à utiliser git rebase, généralement suivi d’un git push --force pour écraser l’historique du serveur (remote) avec l’historique local. Voici comment diviser les commits existants à l’aide de rebase, reset et commit. Supposons que vous ayez deux fichiers édités dans un commit (A et B) et que vous souhaitiez importer les modifications d’un de ces fichiers (A) dans votre branche actuelle, mais pas celles de l’autre (B). Utiliser git cherry-pick <commit-hash> n’est pas une option, car cela impliquerait les modifications pour A et B. La solution consiste à scinder le commit en 2 et à ne sélectionner que le nouveau commit contenant les modifications pour A. Pour faire ça:  lancez git rebase -i <commit-hash>~ (notez le -) ou git rebase -i <hash-of-previous-commit> recherchez le commit que vous voulez scinder dans l’écran d’édition du rebase, changez le pick en e (edit) sauvegardez et quittez (ESC suivi de :wq pour fermer VIM) git reset HEAD~ pour réinitialiser les modifications planifiées (stash) git add [files-to-add] tous les fichiers que nous voulons ajouter au premier commit (ici, ce serait git add A) git commit normalement, avec un message, etc. Exécutez autant de fois que vous le souhaitez: git add [other-files-to-add] git commit git rebase -- continue d’indiquer que la division est terminée et continue la refonte  Enfin, nous pouvons git cherry-pick <new-commit-hash> pour intégrer les modifications dans notre branche.","frontmatter":{"title":"Fractionner un commit existant","subtitle":"Une des choses les plus grandes et les pires avec git est que vous pouvez réécrire l'histoire. Voici une façon sournoise d'abuser de cela, je ne peux pas penser à une raison légitime de le faire."},"fields":{"slug":"/git-splitExistingCommit/"}}},{"node":{"id":"044eb1a1-d28b-5edd-bca2-052da2b0b1bd","timeToRead":7,"excerpt":"Dans cet article, vous apprendrez à créer et à gérer facilement des git hooks pour vos projets Node/NPM à l’aide de Husky. Git Hooks En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent. Des crochets (hooks) côté client sont déclenchés pour des actions telles que le commit ou le merge. Les crochets côté serveur s’exécutent dans des situations telles que la réception de données (git push) du client. Les hooks peuvent exécuter n’importe quelle logique personnalisée et, plus important encore, rejeter l’action effectuée si quelque chose ne va pas. Par exemple, vous pouvez annuler la validation du commit si son message ne contient pas l’ID de problème du suivi des problèmes. Vous pouvez également le refuser si l’analyse de code statique échoue. Cela peut être très utile si vous voulez vous assurer que votre base de code reste propre ou si vous souhaitez appliquer certaines règles de qualité. Mais comment pouvez-vous réellement installer et gérer ces hooks? Chaque fois que vous clonez un repo git, toutes les données git de votre projet sont stockées dans un répertoire .git dans votre dossier. Il contient plusieurs fichiers et sous-répertoires, l’un d’eux étant appelé \u001dhooks\u001d. À l’intérieur, vous trouverez un tas de fichiers.  Chacun d’entre eux est un script, qui est exécuté lorsqu’un événement spécifique se produit. Le nom de l’événement correspond au nom du fichier. Par exemple, la \u001dpre-commit\u001d est exécutée avant de commiter vos modifications. Comme vous pouvez le constater, tous les fichiers ont une extension \u001d.sample\u001d. Git ignore ces fichiers à moins que vous ne les renommiez. Vous devez supprimer l’extension \u001d.sample\u001d pour activer ces hooks. Dans les exemples de fichiers, vous pouvez trouver une description et un exemple d’implémentation que vous pouvez utiliser comme point de départ pour implémenter vos propres hooks. À quoi ça sert? Maintenant, regardons quelques exemples spécifiques de ce qui peut être réalisé avec les git hooks. Comme ce ne sont que des scripts, vous pouvez faire à peu près n’importe quoi. Habituellement, cela signifie effectuer divers contrôles de qualité. Vous pouvez vous assurer que l’utilisateur a son nom et son email renseignés. Vous pouvez vérifier que le message de validation est correctement formaté. Vous pouvez essayer de créer votre application et rejeter le commit si la construction échoue. Vous pouvez exécuter des tests pour vous assurer qu’ils passent avant le commit. L’utilisation typique est également l’analyse de code statique ou le formatage. Cela signifie qu’il faut vérifier dans votre code les problèmes courants, les mauvaises pratiques, les conventions de dénomination, etc. Il peut également être utile d’exécuter un outil tel que Prettier pour s’assurer que le code est bien formaté avant le commit. Cela évite de nombreux maux de tête lors de la révision du code. Vous pouvez même vérifier les failles de sécurité de votre code avec un outil tel que Snyk. Distribution aux membres de l’équipe Avec les hooks côté serveur, la distribution est facile. Vous n’avez généralement qu’un seul référentiel de serveur principal. Cela signifie que tous les membres de l’équipe mettent généralement leurs modifications au même endroit. Vous y installez vos hooks et vous avez terminé. Avec les hooks côté client, cela devient plus compliqué. Lorsque vous clonez un référentiel, les hooks ne sont pas transférés au client. Cela signifie qu’un référentiel fraîchement cloné n’a aucun hook, peu importe le type de hook que vous avez sur le serveur. Si vous voulez que les membres de votre équipe aient un ensemble unifié de git hooks, vous devez les distribuer d’une manière ou d’une autre et vous assurer qu’ils sont inclus dans leur sous-répertoire git hooks. La solution la plus élémentaire consiste à créer un emplacement partagé, où vous stockez vos hooks, puis demandez à vos développeurs de les télécharger et de les mettre dans leur répertoire de hooks. Bien sûr, vous ne pouvez pas être sûr qu’ils le feront réellement. Le problème est qu’ils ont besoin de savoir qu’ils devraient le faire et comment. Et même s’ils le font, ils peuvent être paresseux ou simplement ignorer votre politique. Vous pouvez améliorer un peu cette solution de base en ayant des hooks dans le référentiel de votre projet et en laissant simplement à vos développeurs exécuter un script personnalisé comme celui-ci, qui les copie ensuite dans leur répertoire de hooks. Sinon, git propose une option pour changer la destination du répertoire des hooks en un emplacement personnalisé: Ces solutions facilitent la distribution, mais ne résolvent pas les problèmes essentiels. Husky Installation Vous pouvez installer Husky simplement en exécutant: Alternative, avec yarn: Ajout de hooks Ajouter des hooks avec Husky est facile. Vous devez juste éditer votre package.json. Vous définissez quels scripts doivent être exécutés sur quel événement git. Pour Husky 1.0.0+, utilisez: Si vous utilisez une version de Husky antérieure à 1.0.0 (disponible dans la version candidate du 06/2018), la syntaxe est légèrement différente. Vous ajoutez vos hooks Husky directement dans la section scripts. L’exemple ci-dessus exécute tous vos tests avant de commiter et avant de pousser et si vos tests échouent, l’action git n’est pas exécutée. Bien sûr, vous pouvez exécuter tout autre script nom plutôt que le nom test. Problème de correction automatique avant validation Il est utile de casser le build si quelque chose ne va pas, mais il est encore plus utile de corriger automatiquement les problèmes avant de s’engager. Par exemple, vous pouvez personnaliser votre code en utilisant Prettier avant de faire un commit ou vous pouvez corriger automatiquement les problèmes de formatage, qui peuvent être résolus automatiquement. C’est beaucoup plus facile de cette façon. Heureusement, il existe un outil pour cela. Cela s’appelle lint-staged. Vous pouvez l’installer par: Maintenant, sur votre action de pre-commit, vous exécutez directement \u001dlint-staged\u001d au lieu de votre linter. Dans lint-staged, vous définissez ce qui doit être exécuté: Lorsque vous essayez de commiter maintenant, \u001dlint-staged\u001d peut modifier vos fichiers avant l’exécution de la validation. Cependant, ce qui est vraiment bien, c’est que vous ne filtrez que les fichiers en attente de validation, et non l’ensemble de votre projet. Cela signifie que l’ensemble du processus est beaucoup plus rapide. Bug JetBrains IDE La bonne nouvelle est que les git hooks configurés de cette manière sont exécutés non seulement lorsque vous utilisez git à partir de votre terminal, mais également à partir d’un IDE. La mauvaise nouvelle est que les IDE JetBrains (IDEA, Webstorm, …) ont actuellement un méchant bogue (voir IDEA-135454) et ne fonctionnent pas bien avec cette configuration. Le problème n’est pas résolu avant plusieurs années, mais heureusement, il existe une solution de contournement. Vous devez juste ajouter ce hook post-commit: Bien entendu, il ne s’agit que d’une solution de contournement jusqu’à ce que le problème soit résolu. Le suivi des problèmes de JetBrains contient une fonctionnalité de vote, alors assurez-vous de voter pour que ce problème soit résolu s’il vous pose problème. Intégration continue Une chose à noter est que Husky installe les hooks uniquement lorsqu’il ne s’exécute pas sur un serveur d’intégration continue. Husky peut détecter qu’il est en cours d’exécution dans le cadre d’un travail CI et n’installe aucun hook. En ignorant Les hooks côté client peuvent être utiles, mais vous ne pouvez pas trop compter sur eux. Ils ne sont que le premier niveau de défense. Vous ne pouvez pas être sûr à 100% qu’ils soient exécutés. Ils peuvent être ignorés à la demande en ajoutant une option de ligne de commande: Pour rendre les choses encore plus faciles, les hooks peuvent être désactivés à l’aide de certaines variables environnementales. Pour cette raison, il est toujours utile d’appliquer la même fonctionnalité sur le serveur. Performance Bien que les hooks cotés client tels que le pre-commit puissent s’avérer très utiles, vous devez garder à l’esprit qu’ils prennent un certain temps à s’exécuter. Les commits, qui sont généralement très rapides, car ils ne se produisent que sur le client, peuvent prendre soudainement très longtemps. Vous serez peut-être tenté d’exécuter tous les tests, l’analyse de code statique, les vérifications préalables, etc., avant chaque validation. Lorsqu’un commit prend des années, vos développeurs ne seront pas heureux et seront tentés d’ignorer les hooks lors de l’exécution de leurs commandes git. Vous devez donc trouver le bon équilibre entre ce qui doit être effectué sur le client et ce qui peut être un point d’accès côté serveur. Conclusion Husky est un outil utile qui permet de créer et de gérer facilement des hooks git sur le client. Vous n’avez plus besoin de distribuer vos hooks manuellement. Comme pour tout, gardez le nombre de hooks côté client avec modération afin d’éviter les temps d’exécution trop longs.","frontmatter":{"title":"Git hooks avec Husky","subtitle":"En termes simples, les git hooks sont des scripts personnalisés, qui peuvent être exécutés automatiquement lorsque des événements spécifiques se produisent."},"fields":{"slug":"/git-husky/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/git-husky/","prev":{"excerpt":"Si vous avez un Kindle d’Amazon, vous ne le savez peut-être pas, mais vous possédez une adresse mail ….@kindle.com qui vous permet de vous envoyer des livres et documents directement sur votre liseuse. Pour cela, il faut ajouter votre email via cette page, dans la section “Settings” > “Personal Document Settings” > “Approved Personal Document E-mail List”. Et juste au-dessus, vous devriez voir dans la section “Send-to-Kindle E-Mail Settings”, le ou les emails @kindle.com associés avec chacun de vos appareils Kindle. En effet, en envoyant un fichier depuis votre email référencé vers votre email kindle.com, vous pouvez le transférer vers votre liseuse sans avoir besoin de brancher le moindre câble ou d’installer le moindre soft. Seulement, Amazon autorise l’envoi uniquement des fichiers aux formats suivants : Kindle Format (.MOBI, .AZW) Microsoft Word (.DOC, .DOCX) HTML (.HTML, .HTM) RTF (.RTF) Text (.TXT) JPEG (.JPEG, .JPG) GIF (.GIF) PNG (.PNG) BMP (.BMP) PDF (.PDF) Malheureusement, comme vous pouvez le voir, pas de format epub. Obligé de brancher le Kindle à votre ordinateur et d’utiliser Calibre ? Non, non, non. Il suffit de vous rendre sur le site Send epub to Kindle , puis de renseigner les infos demandées, à savoir votre email référencé, l’email Kindle et de glisser-déposer le livre au format epub de votre choix. Cliquez ensuite sur le bouton vert « Upload & Send » et tadaaaa, au bout de quelques secondes, le livre apparaitra sur votre liseuse Kindle. Elle est pas belle la vie ?","timeToRead":1,"frontmatter":{"title":"Comment envoyer un epub vers une Kindle sans utiliser Calibre ni de cable USB ?","subtitle":"","tags":["Kindle","Ebook"],"category":["Kindle","Ebook"],"date":"2018-11-24T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.5,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGa0ziTSqWf/8QAGBABAQEBAQAAAAAAAAAAAAAAAQIDACL/2gAIAQEAAQUCy0ItmMp9HVjK1mHMj3//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPwFH/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8BV//EABsQAAIDAAMAAAAAAAAAAAAAAAABAhExEBIh/9oACAEBAAY/As8xkujuUlRnFos//8QAGRABAAMBAQAAAAAAAAAAAAAAAQARITFB/9oACAEBAAE/ISa6jh2N3hhGocLS2JPOElOjWf/aAAwDAQACAAMAAAAQ2P8A/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/EIw//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EK2//8QAGxABAQACAwEAAAAAAAAAAAAAAREAMSFRYUH/2gAIAQEAAT8QFwmLUI775mAebFhqWTRLvCPHnyYECp4Z6B6G/HGBI1nef//Z","sizes":"(max-width: 1920px) 100vw, 1920px","src":"/static/e96dc41e5ffd5680b39408b75434d7e0/14dee/kindle.jpg","srcSet":"/static/e96dc41e5ffd5680b39408b75434d7e0/f8f18/kindle.jpg 930w,\n/static/e96dc41e5ffd5680b39408b75434d7e0/0e6ff/kindle.jpg 1860w,\n/static/e96dc41e5ffd5680b39408b75434d7e0/14dee/kindle.jpg 1920w"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/kindle/"}},"next":{"excerpt":"De nos jours, le changement le plus important dans le développement logiciel est la fréquence des déploiements. Les équipes de produits déploient les versions en production plus tôt (et plus souvent). Des cycles de publication de plusieurs mois ou années sont en train de devenir rares, en particulier parmi ceux qui construisent des produits logiciels purs. Aujourd’hui, en utilisant une approche axée sur les services et sur les microservices, les développeurs peuvent concevoir une base de code modulaire. Cela leur permet d’écrire et de déployer des modifications simultanément sur différentes parties de la base de code. Les avantages commerciaux de cycles de déploiement plus courts sont clairs: Le temps de mise sur le marché est réduit Les clients obtiennent la valeur du produit en moins de temps Les commentaires des clients sont également renvoyés plus rapidement dans l’équipe produit, ce qui permet à l’équipe de parcourir les fonctionnalités et de résoudre les problèmes plus rapidement. Le moral des développeurs augmente Cependant, ce changement crée également de nouveaux défis pour les opérations ou l’équipe de DevOps. Avec des déploiements plus fréquents, il est plus probable que le code déployé puisse affecter négativement la fiabilité du site ou l’expérience client. C’est pourquoi il est important de développer des stratégies de déploiement de code minimisant les risques pour le produit et les clients. Dans cet article, nous allons parler de différentes stratégies de déploiement, de meilleures pratiques et d’outils qui permettront à votre équipe de travailler plus rapidement et de manière plus fiable. Défis des applications modernes Les applications modernes sont souvent distribuées et basées sur le cloud. Ils peuvent évoluer pour répondre à la demande et sont plus résistants aux pannes grâce à des architectures hautement disponibles. Ils peuvent utiliser des services entièrement gérés comme AWS Lambda ou Elastic Container Service (ECS), où la plate-forme assume une partie de la responsabilité opérationnelle. Ces applications ont presque toujours des déploiements fréquents. Par exemple, une application mobile ou une application Web grand public peut subir plusieurs modifications au cours d’un mois. Certains sont même déployés en production plusieurs fois par jour. Ils utilisent souvent des architectures de microservices dans lesquelles plusieurs composants travaillent ensemble pour offrir une fonctionnalité complète. Il peut y avoir différents cycles de publication pour différents composants, mais ils doivent tous fonctionner ensemble de manière transparente. L’augmentation du nombre de pièces mobiles signifie plus de chances que quelque chose se passe mal. Avec plusieurs équipes de développement apportant des modifications dans la base de code, il peut être difficile de déterminer la cause première d’un problème inévitablement. Un autre défi: l’abstraction de la couche infrastructure, qui est maintenant considérée comme du code. Le déploiement d’une nouvelle application peut également nécessiter le déploiement d’un nouveau code d’infrastructure. Stratégies de déploiement populaires Pour relever ces défis, les équipes chargées des applications et de l’infrastructure doivent concevoir et adopter une stratégie de déploiement adaptée à leur cas d’utilisation. Nous en examinerons plusieurs et discuterons des avantages et des inconvénients de différentes stratégies de déploiement afin que vous puissiez choisir celle qui convient à votre organisation. Déploiement “Big Bang” Comme son nom l’indique, les déploiements “big bang” mettent à jour des parties entières ou volumineuses d’une application en un seul coup. Cette stratégie remonte à l’époque où le logiciel était publié sur un support physique et installé par le client. Les déploiements à grande échelle ont obligé l’entreprise à procéder à des développements et à des tests approfondis avant la publication, souvent associés au “modèle en cascade” de grandes versions séquentielles. Les applications modernes présentent l’avantage de se mettre à jour régulièrement et automatiquement, côté client ou côté serveur. Cela rend l’approche big bang plus lent et moins agile pour les équipes modernes. Les caractéristiques du déploiement du Big Bang comprennent: Toutes les pièces majeures conditionnées en un seul déploiement; Remplacer en grande partie ou totalement une version de logiciel existante par une nouvelle; Déploiement entraînant généralement de longs cycles de développement et de test; En supposant un risque minimal d’échec, les retours en arrière peuvent être impossibles ou peu pratiques; Les délais de réalisation sont généralement longs et peuvent nécessiter les efforts de plusieurs équipes; Action requise des clients pour mettre à jour l’installation côté client. Les déploiements à fort rendement ne conviennent pas aux applications modernes, car les risques sont inacceptables pour les applications grand public ou critiques pour les entreprises, où les pannes entraînent des pertes financières énormes. Les reculs sont souvent coûteux, prennent du temps, voire impossibles. L’approche big bang peut convenir à des systèmes hors production (par exemple, recréer un environnement de développement) ou à des solutions prêtes à l’emploi, tel que les applications de bureau. Déploiement progressif (Rolling) Les déploiements progressifs, par paliers ou par étapes sont préférables aux déploiements big bang, car ils minimisent de nombreux risques, y compris les temps d’arrêt pour les utilisateurs, sans restauration simple. Dans un déploiement en continu, la nouvelle version d’une application remplace progressivement l’ancienne. Le déploiement réel se produit sur une période de temps. Pendant ce temps, les nouvelles versions et les anciennes versions coexisteront sans affecter la fonctionnalité ou l’expérience utilisateur. Ce processus facilite la restauration de tout nouveau composant incompatible avec les anciens composants. Le diagramme suivant illustre le modèle de déploiement: l’ancienne version apparaît en bleu et la nouvelle version en vert sur chaque serveur du cluster.  Une mise à niveau d’une suite d’applications est un exemple de déploiement progressif. Si les applications d’origine ont été déployées dans des conteneurs, la mise à niveau peut traiter un conteneur à la fois. Chaque conteneur est modifié pour télécharger la dernière image à partir du site du fournisseur de l’application. S’il existe un problème de compatibilité pour l’une des applications, l’ancienne image peut recréer le conteneur. Dans ce cas, les nouvelles versions et les anciennes versions des applications de la suite coexistent jusqu’à ce que chaque application soit mise à niveau. Déploiement Blue-Green, Red-Black ou A/B C’est un autre processus à sécurité intégrée. Dans cette méthode, deux environnements de production identiques fonctionnent en parallèle. L’un est l’environnement de production en cours d’exécution recevant tout le trafic utilisateur (représenté en bleu). L’autre en est un clone, mais inactif (vert). Les deux utilisent la même base de données et la même configuration d’application:  La nouvelle version de l’application est déployée dans l’environnement vert et testée pour ses fonctionnalités et ses performances. Une fois les résultats des tests réussis, le trafic des applications passent du bleu au vert. Le vert devient alors la nouvelle production.  S’il y a un problème après que le vert devient actif, le trafic peut être redirigé vers le bleu. Dans un déploiement Blue-Green, les deux systèmes utilisent la même couche de persistance ou la même base de données. Il est essentiel de synchroniser les données de l’application, mais une base de données en miroir peut aider à atteindre cet objectif. Vous pouvez utiliser la base de données primaire en bleu pour les opérations d’écriture et la base secondaire en vert pour les opérations de lecture. Lors du passage du bleu au vert, la base de données est basculée du primaire au secondaire. Si le vert a également besoin d’écrire des données pendant le test, les bases de données peuvent être en réplication bidirectionnelle. Une fois que le vert devient actif, vous pouvez fermer ou recycler les anciennes instances bleues. Vous pouvez déployer une version plus récente sur ces instances et en faire le nouveau vert pour la prochaine version. Les déploiements Blue-Green reposent sur le routage du trafic. Cela peut être fait en mettant à jour les DNS (CNAMES) pour les hôtes. Cependant, des valeurs TTL longues peuvent retarder ces modifications. Vous pouvez également modifier les paramètres du load balancer pour que les modifications prennent effet immédiatement.  Déploiement canari Le déploiement canari ressemble à du Blue-Green, à la différence qu’il est moins enclin à prendre des risques. Au lieu de passer du bleu au vert en une seule étape, vous utilisez une approche progressive. Avec le déploiement canari, vous déployez un nouveau code d’application dans une petite partie de l’infrastructure de production. Une fois que l’application est validée pour la publication, seuls quelques utilisateurs y sont routés. Cela minimise tout impact. En l’absence d’erreur signalée, la nouvelle version peut progressivement être déployée dans le reste de l’infrastructure. L’image ci-dessous illustre le déploiement canari:  Le principal défi du déploiement canari est de trouver un moyen d’acheminer certains utilisateurs vers la nouvelle application. En outre, certaines applications peuvent toujours avoir besoin du même groupe d’utilisateurs pour les tests, tandis que d’autres peuvent nécessiter un groupe différent à chaque fois. Envisagez un moyen d’acheminer de nouveaux utilisateurs en explorant plusieurs techniques: Exposer les utilisateurs internes au déploiement canari avant d’autoriser l’accès des utilisateurs externes; Baser le routage sur la plage IP source; Livrer l’application dans des régions géographiques spécifiques; Utilisation d’une logique d’application pour déverrouiller de nouvelles fonctionnalités pour des utilisateurs et des groupes spécifiques. Cette logique est supprimée lorsque l’application est en ligne pour le reste des utilisateurs. Meilleures pratiques de déploiement Les équipes d’applications modernes peuvent suivre un certain nombre de meilleures pratiques pour minimiser les risques de déploiement: Utilisez une liste de déploiement. Par exemple, un élément de la liste peut consister à “sauvegarder toutes les bases de données uniquement après que les services d’application ont été arrêtés” afin d’éviter toute corruption des données. Adopter l’intégration continue (CI). CI s’assure que le code archivé dans la branche de fonctionnalité d’un référentiel de code ne fusionne avec sa branche principale qu’après une série de vérifications de dépendance, de tests d’unité et d’intégration et une génération réussit. S’il y a des erreurs le long du chemin, la construction échoue et l’équipe de l’application en est informée. L’utilisation de CI signifie donc que chaque modification apportée à l’application est testée avant son déploiement. Les exemples d’outils de CI incluent: CircleCI, Jenkins. Adoptez la livraison continue (CD). Avec le CD, l’artefact de code construit par le CI est packagé et toujours prêt à être déployé dans un ou plusieurs environnements. Utilisez des environnements d’exploitation standard pour assurer la cohérence de l’environnement. Vous pouvez utiliser des outils tels que Vagrant et Packer pour les postes de travail et les serveurs de développement. Utilisez les outils d’automatisation de build pour automatiser les générations d’environnement. Avec ces outils, il est souvent simple de cliquer sur un bouton pour détruire une pile d’infrastructure complète et la reconstruire à partir de zéro. CloudFormation est un exemple de tels outils. Utilisez des outils de gestion de configuration tels que Puppet, Chef ou Ansible sur les serveurs cibles pour appliquer automatiquement les paramètres du système d’exploitation, appliquer des correctifs ou installer des logiciels. Utilisez des canaux de communication tels que Slack pour les notifications automatisées des générations infructueuses et des échecs d’application. Créez un processus pour alerter l’équipe responsable des déploiements qui échouent. Dans l’idéal, vous les rencontrez dans l’environnement CI, mais si les modifications sont appliquées, vous aurez besoin d’un moyen d’avertir l’équipe responsable. Activez les restaurations automatisées pour les déploiements qui échouent aux vérifications de l’état, que ce soit en raison de problèmes de disponibilité ou de taux d’erreur. Surveillance post-déploiement Même après que vous ayez adopté toutes ces pratiques, il est possible que des choses se passent mal. Pour cette raison, la surveillance des problèmes survenant immédiatement après un déploiement est aussi importante que la planification et l’exécution d’un déploiement parfait. Un outil de surveillance des performances des applications peut aider votre équipe à surveiller les métriques de performances critiques, y compris les temps de réponse du serveur après les déploiements. Les modifications apportées à l’architecture des applications ou du système peuvent affecter considérablement les performances des applications. Une solution de surveillance des erreurs est également essentielle. Il informera rapidement votre équipe des erreurs nouvelles ou réactivées lors d’un déploiement est susceptibles de révéler des bogues importants nécessitant une intervention immédiate. Sans outil de surveillance des erreurs, les bogues n’auraient peut-être jamais été découverts. Alors que quelques utilisateurs rencontrant les bugs prendront le temps de les signaler, la plupart des autres ne le font pas. L’expérience client négative peut entraîner des problèmes de satisfaction au fil du temps ou, pire, empêcher les transactions commerciales d’avoir lieu. Un outil de surveillance des erreurs crée également une visibilité partagée de tous les problèmes de post-déploiement parmi les équipes Opérateur / DevOps et les développeurs. Cette compréhension partagée permet aux équipes d’être plus collaboratives et réactives.","timeToRead":9,"frontmatter":{"title":"Introduction aux stratégies de déploiement","subtitle":"De nos jours, le changement le plus important dans le développement logiciel est la fréquence des déploiements. Les équipes de produits déploient les versions en production plus tôt (et plus souvent).","tags":["CICD","Deploy","DevOps"],"category":["DevOps"],"date":"2019-02-02T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7777777777777777,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAQBAgMF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAFak9W5wHg//8QAGxAAAQQDAAAAAAAAAAAAAAAAAQACAxESISL/2gAIAQEAAQUCKy6E1BuzHEyqC//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAQACAwEAAAAAAAAAAAAAAAABMRESIYH/2gAIAQEABj8C8Qi3WdVP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAERITGR/9oACAEBAAE/IaNiOjRsui2rXBjEiRSTh//aAAwDAQACAAMAAAAQpN//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxBX/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Qp//EABwQAQACAgMBAAAAAAAAAAAAAAEAESFRMUFhwf/aAAgBAQABPxDieh8j0AS9GPIJjMXQwMpryCyIpy61KNPs2wWhNAn/2Q==","sizes":"(max-width: 1600px) 100vw, 1600px","src":"/static/b9929b1a4915b5e4d241ad5af23c0901/989b1/servers.jpg","srcSet":"/static/b9929b1a4915b5e4d241ad5af23c0901/f8f18/servers.jpg 930w,\n/static/b9929b1a4915b5e4d241ad5af23c0901/989b1/servers.jpg 1600w"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/deploy/"}},"primaryTag":"Git","primaryCategory":"Git"}}}