{"componentChunkName":"component---src-templates-post-tsx","path":"/node-sequelize-pagination/","webpackCompilationHash":"28b74a5dec589e4586df","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQY023PvUrDUBTA8ZuCtoMoOLQ4dWhN14x2kEKXFkGoohQ/QBexOHRycAidKkgHHRq69APRoTjFJYODIA6+gSBYfYMmfYLE/5VT6NALP845NyeHc9UoCHZRQvonCLKKE4ZhAXYURTsYoE9dIy5iCzfUJnEdV+RF4iu6ikFH2EPxazzOcJmg4Rnn5C8ysIEOHqTe5/sT3qXOwYOtRr5/wLAqzpCTDXu4p2ETtyjgGJ/cX+se8jeU9fa4RBt5vWENpjzdkoGPcGg4RQsbOMEFmnBRRwVDHEK/yFXfvr/CoPjvZLKcdByDyzWGeajigzorGy0oOeRJiUtITe/pX1XzDk3buIMltSFR/zTtic3060X+8z8PsEUt8G3LVQAAAABJRU5ErkJggg==","width":400,"height":128,"src":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png","srcSet":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png 1x"}}},"markdownRemark":{"html":"<p>Souvent, je me trouve aux prises avec Sequelize pour trouver une réponse directe à ma requête. Récemment, je travaillais sur une application full stack dans laquelle il était impératif de paginer les résultats depuis le backend (API REST) vers le client. Je me suis battu pour deux raisons. Tout d’abord, venant du context NoSQL, il est difficile de saisir les bases de données SQL. La deuxième raison étant que la documentation de Sequelize ne fournit pas une solution claire et directe à cette abstraction très basique. Beaucoup de gens supposent des choses dans le monde des bases de données SQL.</p>\n<p>Ainsi, dans cet article, nous allons parler d’un module de base de pagination utilisant Sequelize, MySQL et Node.js. J’utilise des tables et des enregistrements dans votre base de données MySQL. Pour configurer une nouvelle application et établir une connexion à une base de données, lisez mon post sur <code>Premiers pas avec Sequelize</code>.</p>\n<h2>Définir un modèle</h2>\n<p>Je saute directement sur la définition du modèle utilisateur:</p>\n<p>J’utilise une table contenant une centaine d’enregistrements d’utilisateur que nous voulons afficher sur une application Web, par exemple dans le panneau d’administration, et nous voulons afficher seulement 50 enregistrements à la fois.</p>\n<p>Dans le fichier <code>api/user.js</code>, je définis un endpoint <code>/:page</code> qui extraira le nombre de résultats nécessaires de la base de données.</p>\n<p><code>findAndCountAll</code> est le modèle de recherche dans plusieurs enregistrements de la base de données. Il retourne à la fois les données requises et le nombre d’éléments de cette table. La requête ci-dessus obtiendra 50 enregistrements d’utilisateur à la fois jusqu’à ce que la page suivante soit appelée pour extraire les 50 prochains enregistrements. <code>limit</code> et <code>offset</code> sont nécessaires dans les requêtes liées à la pagination dans lesquelles <code>limit</code> extrait le nombre de lignes en fonction de la requête, tandis que <code>offset</code> est utilisé pour ignorer le nombre</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Souvent, je me trouve aux prises avec Sequelize pour trouver une réponse directe à ma requête. Récemment, je travaillais sur une application full stack dans laquelle il était impératif de paginer les résultats depuis le backend (API REST) vers le client. Je me suis battu pour deux raisons. Tout d’abord, venant du context NoSQL, il est difficile de saisir les bases de données SQL. La deuxième raison étant que la documentation de Sequelize ne fournit pas une solution claire et directe à cette abstraction très basique. Beaucoup de gens supposent des choses dans le monde des bases de données SQL."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ainsi, dans cet article, nous allons parler d’un module de base de pagination utilisant Sequelize, MySQL et Node.js. J’utilise des tables et des enregistrements dans votre base de données MySQL. Pour configurer une nouvelle application et établir une connexion à une base de données, lisez mon post sur "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Premiers pas avec Sequelize"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Définir un modèle"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Je saute directement sur la définition du modèle utilisateur:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"J’utilise une table contenant une centaine d’enregistrements d’utilisateur que nous voulons afficher sur une application Web, par exemple dans le panneau d’administration, et nous voulons afficher seulement 50 enregistrements à la fois."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Dans le fichier "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"api/user.js"}]},{"type":"text","value":", je définis un endpoint "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"/:page"}]},{"type":"text","value":" qui extraira le nombre de résultats nécessaires de la base de données."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"findAndCountAll"}]},{"type":"text","value":" est le modèle de recherche dans plusieurs enregistrements de la base de données. Il retourne à la fois les données requises et le nombre d’éléments de cette table. La requête ci-dessus obtiendra 50 enregistrements d’utilisateur à la fois jusqu’à ce que la page suivante soit appelée pour extraire les 50 prochains enregistrements. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"limit"}]},{"type":"text","value":" et "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"offset"}]},{"type":"text","value":" sont nécessaires dans les requêtes liées à la pagination dans lesquelles "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"limit"}]},{"type":"text","value":" extrait le nombre de lignes en fonction de la requête, tandis que "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"offset"}]},{"type":"text","value":" est utilisé pour ignorer le nombre"}]}],"data":{"quirksMode":false}},"excerpt":"Souvent, je me trouve aux prises avec Sequelize pour trouver une réponse directe à ma requête. Récemment, je travaillais sur une application full stack dans laquelle il était impératif de paginer les résultats depuis le backend (API REST) vers le client. Je me suis battu pour deux raisons. Tout d’abord, venant du context NoSQL, il est difficile de saisir les bases de données SQL. La deuxième raison étant que la documentation de Sequelize ne fournit pas une solution claire et directe à cette abstraction très basique. Beaucoup de gens supposent des choses dans le monde des bases de données SQL. Ainsi, dans cet article, nous allons parler d’un module de base de pagination utilisant Sequelize, MySQL et Node.js. J’utilise des tables et des enregistrements dans votre base de données MySQL. Pour configurer une nouvelle application et établir une connexion à une base de données, lisez mon post sur Premiers pas avec Sequelize. Définir un modèle Je saute directement sur la définition du modèle utilisateur: J’utilise une table contenant une centaine d’enregistrements d’utilisateur que nous voulons afficher sur une application Web, par exemple dans le panneau d’administration, et nous voulons afficher seulement 50 enregistrements à la fois. Dans le fichier api/user.js, je définis un endpoint /:page qui extraira le nombre de résultats nécessaires de la base de données. findAndCountAll est le modèle de recherche dans plusieurs enregistrements de la base de données. Il retourne à la fois les données requises et le nombre d’éléments de cette table. La requête ci-dessus obtiendra 50 enregistrements d’utilisateur à la fois jusqu’à ce que la page suivante soit appelée pour extraire les 50 prochains enregistrements. limit et offset sont nécessaires dans les requêtes liées à la pagination dans lesquelles limit extrait le nombre de lignes en fonction de la requête, tandis que offset est utilisé pour ignorer le nombre","timeToRead":1,"frontmatter":{"title":"Comment paginer des enregistrements dans MySQL avec Sequelize et Nodejs","subtitle":"","userDate":"13 October 2018","date":"2018-10-13T08:00:00.000Z","tags":["Sequelize","Node.js","Javascript"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABc/i1RhGH/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAMBAhEEE//aAAgBAQABBQKvRtmuqontsQqdanTwP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/Aar/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGI/8QAHBAAAQMFAAAAAAAAAAAAAAAAAAEiMQIREjLh/9oACAEBAAY/An0mV5g4bqI4k//EABoQAQACAwEAAAAAAAAAAAAAAAEAESFBUfH/2gAIAQEAAT8hKyhSrJs7VFOGpdNmVqHIjzP/2gAMAwEAAgADAAAAEOPv/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8QhD//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/EA//xAAfEAEAAgIABwAAAAAAAAAAAAABABEhMUFRYXGhsfD/2gAIAQEAAT8Q65gFNZ8S8YYMuKrcvBhNcPuECl5hEFdEsYiW1/O8/9k=","aspectRatio":1.4992503748125936,"src":"/static/e47b6c69cbe49a04cdbe6e0e621f405f/883ab/open-book.jpg","srcSet":"/static/e47b6c69cbe49a04cdbe6e0e621f405f/f8f18/open-book.jpg 930w,\n/static/e47b6c69cbe49a04cdbe6e0e621f405f/0e6ff/open-book.jpg 1860w,\n/static/e47b6c69cbe49a04cdbe6e0e621f405f/883ab/open-book.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"ludo","name":"Wyffels Ludovic","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png 1x"}}]}}}},"relatedPosts":{"totalCount":5,"edges":[{"node":{"id":"fd0129ff-6bcb-5c81-a195-706bf1378cb8","timeToRead":4,"excerpt":"La spécification ES2015 ou ES6 a introduit la class en JavaScript. Des bibliothèques telles que React sont passées de React.createClass à la class MyComponent extends React.Component, c’est-à-dire qu’ils sont passés de l’utilisation de leur propre constructeur à l’utilisation d’un langage intégré pour transmettre l’intention du programmeur. Pour la couche de persistance d’une application Web Node.js, quelques bases de données me viennent à l’esprit, comme MongoDB (éventuellement associé à mongoose), ou une association de clés-valeurs comme Redis. Pour exécuter une base de données relationnelle avec une application Node, Sequelize , “Un ORM de dialecte multi-SQL facile à utiliser pour Node.js” est une bonne option. Il permet à l’application de fonctionner avec une instance MySQL ou PostgreSQL et offre un moyen simple de mapper la représentation des entités dans la base de données vers JavaScript et inversement. Les API v4 et inférieure de Sequelize pour les définitions de modèle se présentent comme suit: Pour ajouter des méthodes de classes et d’instance, vous devez écrire ce qui suit: Cela est nécessaire avant l’ES6 car il n’existait pas de notion d’héritage classique. Maintenant, nous avons les classes, pourquoi ne pas les exploiter? Pour les développeurs habitués à avoir des classes, les éléments suivants vous sembleront probablement familiers: Sequelize supporte réellement cela, mais la documentation manque un peu. L’un des seuls endroits où trouver une référence à la procédure à suivre est dans un numéro de GitHub: https://github.com/sequelize/sequelize/issues/6524. Voici un aide-mémoire sur ce que vous souhaitez faire et comment le réaliser à l’aide de la classe ES6 + héritage de Sequelize.Model:  Initialiser le modèle avec le ou les champs saisis Associez votre modèle à d’autres modèles Définition d’un nom de table personnalisé pour votre modèle Définition d’un nom de modèle personnalisé pour votre modèle (pour Sequelize) Les requêtes Méthodes d’instance Initialisez tous vos modèles  Initialiser le modèle avec le ou les champs saisis  Associez votre modèle à d’autres modèles  Définition d’un nom de table personnalisé pour votre modèle  Définition d’un nom de modèle personnalisé pour votre modèle (pour Sequelize)  Les requêtes  Méthodes d’instance  Initialisez tous vos modèles require() suivi de model.init() est une alternative à sequelize.import(path), il est un peu plus clair ce qui est importé et non importé et sous quel nom.","frontmatter":{"title":"Utilisation des classes ES6 pour les modèles Sequelize 4 ou 5","subtitle":"Sequelize supporte les classe ES6, mais la documentation manque un peu."},"fields":{"slug":"/node-sequelize-classes/"}}},{"node":{"id":"5e988c68-722d-551c-a1e7-bd423ed18bbd","timeToRead":3,"excerpt":"Les DataTypes sont au coeur de la bibliothèque Sequelize. Ceci est un guide pratique et complet pour compenser la documentation officielle clairsemée de Sequelize sur le sujet. Tout d’abord, DataTypes contient à la fois les types et les générateurs pour les valeurs par défaut: NOW , \u001dUUIDV1 et UUIDV4 sont des valeurs par défaut spéciales. Les endroits où vous êtes susceptible de rencontrer des DataTypes se trouvent dans la définition du champ de modèle et dans les définitions de migration. Notez que pour un modèle et un champ donnés, le type de données doit être identique dans le modèle et dans la migration. Table des matières: Types de texte Les valeurs par défaut Nombre Types primitifs fantaisie Date/heure Types de fantaisie Types fantaisie Postgres  Types de texte STRING Une chaîne de longueur variable. Longueur par défaut 255. Prend en charge BINARY Utilisation: une chaîne binaire de 100 longueurs DataTypes.STRING(100).BINARY CHAR Une chaîne de longueur fixe. Longueur par défaut 255. Prend en charge BINARY Utilisation: un caractère binaire de 100 longueurs DataTypes.CHAR(100).BINARY TEXT : une colonne de texte de longueur illimitée  Les valeurs par défaut NOW : une valeur par défaut de l’horodatage actuel UUIDV1 : Un identifiant universel unique par défaut généré conformément à la norme UUID v1 UUIDV4 : Un identifiant universel unique par défaut généré conformément à la norme UUID v2  Nombre Tous les éléments suivants prennent en charge ces propriétés: UNSIGNED, ZEROFILL. Par exemple: La même chose peut être faite en utilisant BIGINT.UNSIGNED, FLOAT.UNSIGNED,… INTEGER: Un entier de 32 bits. BIGINT: Un entier de 64 bits. FLOAT: nombre à virgule flottante (précision sur 4 octets). Accepte un ou deux arguments de précision REAL: nombre à virgule flottante (précision sur 4 octets). Accepte un ou deux arguments de précision DOUBLE: nombre à virgule flottante (précision sur 8 octets). Accepte un ou deux arguments de précision DECIMAL: nombre décimal. Accepte un ou deux arguments de précision  Types primitifs fantaisie BOOLEAN: colonne booléenne / tinyint qui est forcée de devenir un booléen JavaScript. UUID: Une colonne contenant un identifiant universel unique, la forme est validée, à utiliser avec les valeurs par défaut UUIDV1 ou UUIDV4  Date/heure TIME: une colonne de temps DATE: une colonne datetime DATEONLY: Une colonne de date seulement  Types fantaisie BLOB: Stockage binaire. Longueurs disponibles: tiny, medium, long. Par exemple: DataTypes.BLOG('tiny') VIRTUAL Une valeur virtuelle qui n’est pas stockée dans la base de données. Cela peut par exemple être utile si vous souhaitez fournir une valeur par défaut dans votre modèle, qui est renvoyée à l’utilisateur mais non stockée dans la base de données. Voir les docs ENUM Une énumération. DataTypes.ENUM('value', 'another value') Idéalement, devrait être utilisé avec les chaînes stockées dans les constantes  Types fantaisie Postgres HSTORE: une colonne clé/valeur JSON: une colonne de chaîne JSON. JSONB: une colonne de données JSON pré-traitée. RANGE: Pour Postgres 9.4+, les types de plage sont des types de données représentant une plage de valeurs d’un type d’élément (appelé sous-type de plage). ARRAY Un tableau de type, par exemple DataTypes.ARRAY(DataTypes.DECIMAL)","frontmatter":{"title":"Sequelize DataTypes: guide pratique","subtitle":"Les DataTypes sont au coeur de la bibliothèque Sequelize. Ceci est un guide pratique et complet pour compenser la documentation officielle clairsemée de Sequelize sur le sujet."},"fields":{"slug":"/node-sequelize-datatypes/"}}},{"node":{"id":"b731f027-ed03-5594-935a-73542795e5cd","timeToRead":1,"excerpt":"Introduction à l’ORM ORM ou Object Relation Mapping est un processus de mappage entre des objets et des systèmes de base de données relationnels. Un ORM agit comme une interface entre deux systèmes. Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier. Le code est robuste au lieu de redondant. ORM aide à gérer les requêtes sur plusieurs tables de manière efficace. Enfin, un ORM (comme sequelize) est capable de se connecter à différentes bases de données (ce qui est pratique lors du passage d’une base de données à une autre). Démarrer avec Sequelize Débuter avec Sequelize Sequelize est un ORM basé sur des promesses pour Node.js. Sequelize est facile à apprendre et possède des dizaines de fonctionnalités intéressantes comme la synchronisation, l’association, la validation, etc. Il prend également en charge PostgreSQL, MySQL, MariaDB, SQLite et MSSQL. J’utilise actuellement PostgreSQL. Installation Sequelize est disponible via npm. Établissement d’une connexion Sequelize établit une connexion entre l’API / application restante et votre base de données SQL. Pour configurer la connexion de base entre les deux:","frontmatter":{"title":"Démarrer avec Sequelize","subtitle":"Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier."},"fields":{"slug":"/node-sequelize-intro/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/node-sequelize-pagination/","prev":{"excerpt":"Introduction à l’ORM ORM ou Object Relation Mapping est un processus de mappage entre des objets et des systèmes de base de données relationnels. Un ORM agit comme une interface entre deux systèmes. Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier. Le code est robuste au lieu de redondant. ORM aide à gérer les requêtes sur plusieurs tables de manière efficace. Enfin, un ORM (comme sequelize) est capable de se connecter à différentes bases de données (ce qui est pratique lors du passage d’une base de données à une autre). Démarrer avec Sequelize Débuter avec Sequelize Sequelize est un ORM basé sur des promesses pour Node.js. Sequelize est facile à apprendre et possède des dizaines de fonctionnalités intéressantes comme la synchronisation, l’association, la validation, etc. Il prend également en charge PostgreSQL, MySQL, MariaDB, SQLite et MSSQL. J’utilise actuellement PostgreSQL. Installation Sequelize est disponible via npm. Établissement d’une connexion Sequelize établit une connexion entre l’API / application restante et votre base de données SQL. Pour configurer la connexion de base entre les deux:","timeToRead":1,"frontmatter":{"title":"Démarrer avec Sequelize","subtitle":"Les ORM offrent aux développeurs des avantages de base, tels que la réduction du temps et des efforts et la concentration sur la logique métier.","tags":["Sequelize","Node.js","Javascript"],"category":["Node.js"],"date":"2018-10-12T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7777777777777777,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAUlEQVQoz2P4DwP//v//8+//33//iQcM2AT/AQGxmiEK3/3+33H75/Jnf/4QbzPEjucff7ptfym87JHMiofVO67fv/v489fvQPt//Pz19+9fkNHvP3389PXXrz+/fyMMZ/gL1n3p8Se7vhNS9buVchfm180+c+HW1j2n9x+5uGnHicvXHmzedXLdliOnzt3cffD8+q1Hf/78hWLz3VdffSefMq3bZhbdXt264O37z7fuPn3+8t3Zi7fvPXh++97Tx09fv3j1/t6jF/cePv8DdguKn689/1q37MyM+VvevP0ICTTSQvv3H6gWIPnvHzTMYWwUQXTNEGE0aTLi+T89NAMA0+5wRDWkongAAAAASUVORK5CYII=","sizes":"(max-width: 1600px) 100vw, 1600px","src":"/static/335caa592debcad471a1ec9936833b1b/9ecf6/sequelize.png","srcSet":"/static/335caa592debcad471a1ec9936833b1b/4c9af/sequelize.png 930w,\n/static/335caa592debcad471a1ec9936833b1b/9ecf6/sequelize.png 1600w"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/node-sequelize-intro/"}},"next":{"excerpt":"J’ai installé Docker Swarm et Kubernetes sur deux machines virtuelles. J’ai trouvé que Docker Swarm est très facile à installer et à configurer, alors que Kubernetes est un peu plus difficile à installer mais reste simple à utiliser. Introduction Cela fait des années que je veux essayer des conteneurs: la configuration manuelle de serveurs prend du temps, n’est pas reproductible et risque d’introduire des différences entre mon environnement de test local et la production. Les containers offrent une solution à tous ces problèmes et facilite beaucoup l’exécution d’instances supplémentaires d’une application. Cela peut rendre un service plus évolutif. Pour exécuter un service évolutif, vous avez besoin d’un moteur Container Orchestration qui répartit la charge en exécutant des conteneurs sur plusieurs ordinateurs et en envoyant des demandes à chaque instance de l’application. Docker Swarm et Kubernetes sont deux moteurs d’orchestration populaires. J’ai décidé d’essayer les deux en déployant la même application avec chaque moteur. Création du conteneur J’ai décidé d’utiliser Samba pour l’application de test. Samba est un serveur de fichiers populaire permettant aux ordinateurs Linux de partager des fichiers avec des ordinateurs Windows. Il communique via TCP sur le port 445. C’est la première fois que je travaille avec Docker, j’ai donc modifié un conteneur Samba standard afin d’inclure le fichier que je voulais servir. Après le tutoriel de Docker, j’ai lancé manuellement le conteneur à partir de la ligne de commande pour vérifier son fonctionnement: Et en effet, j’ai pu me connecter au serveur Samba dans le conteneur avec smbclient Maintenant que je sais que le conteneur fonctionne, je peux l’utiliser dans un moteur d’orchestration de conteneur. Préparer les machines virtuelles J’ai créé deux machines virtuelles exécutant Ubuntu 18.04 dans VirtualBox. J’ai ajouté une carte réseau supplémentaire à chaque machine virtuelle, configurée pour le réseau interne afin qu’ils puissent se parler: https://cdn-images-1.medium.com/max/1600/1*chCjRdcU_mV9ioAyQ7oB5A.png Ensuite, j’ai ajouté un serveur DHCP pour attribuer des adresses IP à chaque machine virtuelle: Les machines virtuelles peuvent désormais communiquer entre elles. Cela donne à ma machine virtuelle principale l’adresse IP 10.133.7.100. Docker Swarm Docker Swarm est un moteur d’orchestration de conteneur intégré à Docker lui-même. Quand je l’ai trouvé, j’étais sceptique: pourquoi l’utiliser à la place des Kubernetes, beaucoup plus célèbres? La réponse: Docker Swarm est axé sur la simplicité par rapport à la configuration. Cela ressemblait à l’iOS des moteurs d’orchestration de conteneurs par rapport à l’Android de Kubernetes. Mise en place de Docker Swarm Docker Swarm est facile à installer: il suffit d’installer Docker et docker-compose. Ensuite, après le tutoriel officiel, j’ai exécuté la seule commande nécessaire pour démarrer le noeud du gestionnaire, en transmettant l’adresse IP de la machine virtuelle actuelle: C’est tout: le moteur Docker tourne maintenant en mode Swarm. Ensuite, j’ai déployé un registre privé Docker afin que les autres noeuds puissent extraire des images, en suivant à nouveau les instructions d’installation: Déploiement de l’application Docker Swarm utilise le format Docker Compose pour spécifier les conteneurs à exécuter et les ports qu’ils exportent. Après le didacticiel Docker Compose, j’ai créé ce manifeste Docker Compose: Cela indique à Docker Compose de créer le fichier Docker à partir du répertoire «sambaonly», d’upload/pull les conteneurs construits vers mon registre privé nouvellement configuré et d’exporter le port 445 à partir du conteneur. Pour déployer ce manifeste, j’ai suivi le tutoriel de Docker Swarm. J’ai d’abord utilisé Docker Compose pour créer et télécharger le conteneur dans le registre privé: Une fois le conteneur créé, l’application peut être déployée avec la commande docker stack deploy, en spécifiant le nom du service: Et maintenant, l’application fonctionne sous Samba Swarm. J’ai testé qu’il fonctionne toujours avec smbclient: Ajout d’un autre noeud Ici encore, la simplicité de Docker Swarm transparaît. Pour installer un deuxième noeud, j’ai d’abord installé Docker, puis exécuté la commande que Docker m’avait donnée lors de l’installation de swarm: Pour exécuter mon application sur les deux nœuds, j’ai exécuté la commande scale de Docker Swarm sur le nœud du gestionnaire: Sur le nouveau noeud de travail, le nouveau conteneur est apparu: Test de l’équilibrage de charge (load balancing) Docker Swarm comprend un load balancing intégré appelé routeur Mesh: les demandes adressées à l’adresse IP de tout noeud sont automatiquement réparties sur l’ensemble de Swarm. Pour tester cela, j’ai établi 1000 connexions à l’adresse IP du noeud du gestionnaire avec nc: Samba génère un nouveau processus pour chaque connexion. Par conséquent, si l’équilibrage de la charge fonctionne, je m’attendrais à environ 500 processus Samba sur chaque noeud de Swarm. C’est bien ce qui se passe. Après avoir exécuté le script pour établir 1000 connexions, j’ai vérifié le nombre de processus Samba sur le gestionnaire (10.133.7.100): Et sur le noeud travailleur (10.133.7.50): Ainsi, exactement la moitié des demandes adressées au noeud de gestion ont été redirigées de manière magique vers le premier noeud de travail, ce qui montre que le cluster Swarm fonctionne correctement. J’ai trouvé que Docker Swarm était très facile à installer et il fonctionnait bien sous une charge (légère). Kubernetes Kubernetes est en train de devenir l’industrie standard de l’orchestration de conteneurs. C’est beaucoup plus flexible que Docker Swarm, mais cela rend plus difficile la configuration. Je l’ai trouvé pas si difficile, cependant. Pour cette expérience, au lieu d’utiliser un environnement de développement Kubernetes pré-construit tel que minikube, j’ai décidé de configurer mon propre cluster, à l’aide de Kubadm, WeaveNet et MetalLB. Mise en place de Kubernetes Kubernetes à la réputation d’être difficile à configurer: vous avez entendu le processus complexe en plusieurs étapes du didacticiel Kubernetes the Hard Way Les développeurs de Kubernetes ont simplifié l’utilisation de kubeadm. Malheureusement, Kubernetes étant si flexible, le tutoriel sur kubeadm ne couvre pas encore quelques étapes. J’ai donc dû déterminer le réseau et l’équilibreur de charge à utiliser moi-même. Voici ce que j’ai fini par lancer. J’ai d’abord dû désactiver Swap sur chaque noeud: Ensuite, j’ai configuré le noeud maître (10.133.7.100) avec la commande suivante: L’option --pod-network-cidr attribue une adresse réseau interne à tous les noeuds du réseau, utilisée pour les communications internes dans Kubernetes. Les options --apiserver-advertise-address et --apiserver-cert-extra-sans ont été ajoutées à cause d’un problème particulier dans l’installation de VirtualBox: la carte virtuelle principale des machines virtuelles (IP 10.0.2.15) ne peut accéder qu’à l’Internet. J’ai dû préciser que d’autres noeuds doivent accéder au maître à l’aide de l’adresse IP 10.133.7.100. Après avoir exécuté cette commande, Kubeadm a affiché quelques instructions: J’ai raté ces instructions la première fois et je n’ai donc pas terminé la configuration. J’ai ensuite passé une semaine entière à me demander pourquoi aucun de mes conteneurs ne fonctionnait! Après avoir enfin lu les instructions, je devais faire trois autres choses: Tout d’abord, je devais exécuter les commandes données par kubeadm pour configurer un fichier de configuration. Par défaut, Kubernetes ne planifie pas les conteneurs sur le nœud maître, mais uniquement sur les noeuds de travail. Comme je n’ai qu’un seul noeud pour le moment, le tutoriel m’a montré cette commande pour autoriser l’exécution de conteneurs sur le seul noeud: Enfin, je devais choisir un réseau pour mon cluster. Installation du réseau Contrairement à Docker Swarm, qui doit utiliser sa propre couche de routage maillé pour la mise en réseau et l’équilibrage de la charge, Kubernetes offre de multiples choix pour la mise en réseau et l’équilibrage de la charge. Le composant de mise en réseau permet aux conteneurs de communiquer en interne. J’ai fait des recherches et cet article comparatif suggérait Flannel ou WeaveNet, car ils sont faciles à configurer. Ainsi, j’ai décidé d’essayer WeaveNet. J’ai suivi les instructions du didacticiel kubeadm pour appliquer la configuration de WeaveNet: Ensuite, pour permettre aux conteneurs de communiquer avec le monde extérieur, j’ai besoin d’un équilibreur de charge. D’après mes recherches, j’ai eu l’impression que la plupart des implémentations de l’équilibreur de charge Kubernetes se concentrent uniquement sur les services HTTP, et non sur le TCP brut. Heureusement, j’ai trouvé MetalLB, un projet récent (vieux d’un an) qui comble cette lacune. Pour installer MetalLB, j’ai suivi son didacticiel de mise en route et j’ai tout d’abord déployé MetalLB: Ensuite, j’ai attribué la plage d’adresses IP 10.133.7.200 à 10.133.7.230 à MetalLB, en créant et en appliquant ce fichier de configuration: Déploiement de l’application Les fichiers de configuration du service de Kubernetes sont plus détaillés que ceux de Docker Swarm, en raison de la flexibilité de Kubernetes. En plus de spécifier le conteneur à exécuter, comme Docker Swarm, je dois spécifier comment chaque port doit être traité. Après avoir lu le tutoriel de Kubernetes, j’ai proposé cette configuration de Kubernetes, composée d’un service et d’un déploiement. https://gist.github.com/ludovicwyffels/911bb25b611f3519745aeee0d53c6447 Ce service demande à Kubernetes d’exporter le port TCP 445 de nos conteneurs Samba vers l’équilibreur de charge. https://gist.github.com/ludovicwyffels/41022da159c539e45027c68776f459d8 Cet objet Deployment indique à Kubernetes d’exécuter mon conteneur et d’exporter un port que le service doit gérer. Notez le replicas: 1 - c’est le nombre d’instances du conteneur que je veux exécuter. Je peux déployer ce service sur Kubernetes en utilisant kubectl apply: Et, après avoir redémarré ma machine virtuelle à quelque reprises, le déploiement a finalement commencé à fonctionner: Mon service est maintenant disponible sur l’adresse IP externe attribuée par MetalLB: Ajout d’un autre noeud Ajouter un autre noeud dans un cluster Kubernetes est beaucoup plus simple: il me suffisait d’exécuter la commande donnée par kubeadm sur le nouvel ordinateur: Bizarreries de ma configuration J’ai dû faire deux changements en raison de la configuration de VirtualBox: Premièrement, comme ma machine virtuelle dispose de deux cartes réseau, je dois indiquer manuellement l’adresse IP de ma machine à Kubernetes. Selon ce problème, je devais éditer Et changer une ligne en avant de redémarrer Kubernetes: L’autre solution concerne le registre Docker: comme le nouveau noeud ne peut accéder à mon registre privé sur le noeud maître, j’ai décidé de procéder à un terrible hack et de partager le registre de mon noeud maître vers la nouvelle machine à l’aide de ssh: Cela transmet le port 5000 du noeud principal, dora (qui exécute le registre Docker) à localhost, où Kubernetes peut le trouver sur cette machine. En production réelle, il est probable que le registre Docker sera hébergé sur une machine distincte, afin que tous les noeuds puissent y accéder. “Scaling” de l’application Lors de la deuxième installation de l’ordinateur, j’ai modifié mon déploiement d’origine pour ajouter une autre instance de l’application: Après avoir redémarré le maître et le worker à quelques reprises, la nouvelle instance de mon application a finalement quitté le statut de CreatingContainer et a commencé à s’exécuter: Test de l’équilibrage de charge J’ai utilisé la même procédure pour ouvrir 1000 connexions à Samba s’exécutant sur Kubernetes. Le résultat est intéressant. Master: Worker: Kubernetes / MetalLB a également équilibré la charge sur les deux machines, mais la machine principale a eu un peu moins de connexions que le worker. Je me demande pourquoi. Quoi qu’il en soit, cela montre que j’ai finalement réussi à installer Kubernetes après plusieurs détours. Comparaison et conclusion Fonctionnalités communes aux deux: les deux peuvent gérer des conteneurs et gérer intelligemment les demandes d’équilibrage de charge sur la même application TCP sur deux machines virtuelles différentes. Les deux ont une bonne documentation pour la configuration initiale. Les atouts de Docker Swarm: une configuration simple, aucune configuration requise, une intégration étroite avec Docker. Les points forts de Kubernetes: composants souples, nombreuses ressources disponibles et add-ons. Kubernetes vs Docker Swarm est un compromis entre simplicité et flexibilité. J’ai trouvé plus facile d’installer Docker Swarm, mais je ne peux pas, par exemple, échanger l’équilibreur de charge contre un autre composant. Il n’ya aucun moyen de le configurer: je devrais tout désactiver en même temps. Sur Kubernetes, il m’a fallu un certain temps pour trouver la bonne configuration, mais en échange, je pouvais changer certaines parties de mon cluster selon les besoins et installer facilement des add-ons, tels qu’un tableau de bord sophistiqué. Si vous voulez juste essayer Kubernetes sans toute cette configuration, je vous suggère d’utiliser minikube, qui offre une machine virtuelle de cluster Kubernetes prédéfinie, aucune installation requise. Enfin, je suis impressionné par le fait que les deux moteurs ont pris en charge les services TCP bruts: d’autres fournisseurs de services d’infrastructure en tant que services, tels que Heroku ou Glitch, ne prennent en charge que l’hébergement de sites Web HTTP. La disponibilité des services TCP signifie que l’on peut déployer ses propres serveurs de base de données, ses serveurs de cache et même ses serveurs Minecraft en utilisant les mêmes outils pour déployer des applications Web, faisant de la gestion de l’orchestration de conteneurs une compétence très utile. En conclusion, si je construisais un cluster, j’utiliserais Docker Swarm. Si je payais quelqu’un d’autre pour construire un cluster pour moi, je demanderais Kubernetes. Ce que j’ai appris Comment travailler avec les conteneurs Docker Comment configurer un cluster Docker Swarm à deux noeuds Comment configurer un cluster Kubernetes à deux noeuds et quels choix fonctionneraient pour une application basée sur TCP Comment déployer une application sur Docker Swarm et Kubernetes Comment réparer quoi que ce soit en redémarrant un ordinateur assez souvent, comme si je utilisais encore Windows 98 Kubernetes et Docker Swarm ne sont pas aussi intimidants qu’ils semblent","timeToRead":16,"frontmatter":{"title":"Docker Swarm vs Kubernetes","subtitle":"J'ai trouvé que Docker Swarm est très facile à installer et à configurer, alors que Kubernetes est un peu plus difficile à installer mais reste simple à utiliser.","tags":["Kubernetes","Docker","DevOps"],"category":["DevOps"],"date":"2018-11-01T08:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7772511848341233,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAAB6OtBGFa2/8QAGhABAAIDAQAAAAAAAAAAAAAAAQACAxESE//aAAgBAQABBQJyW7vkSe1iaNoIBU//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQMBAT8Bia//xAAZEQABBQAAAAAAAAAAAAAAAAAAAQIRElH/2gAIAQIBAT8BlCzcP//EABoQAAMBAAMAAAAAAAAAAAAAAAABESESMUH/2gAIAQEABj8CU6MU30k5FhGRKH//xAAbEAEAAgIDAAAAAAAAAAAAAAABABEhQTFRYf/aAAgBAQABPyHjwtkhQI2lwNVg2E1C5WkTplYQ8n//2gAMAwEAAgADAAAAEAjv/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAhYf/aAAgBAwEBPxAQO3S//8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAgEBPxDsOTD/xAAaEAEBAQADAQAAAAAAAAAAAAABEQAhMUFx/9oACAEBAAE/EEhJlEVOtxTFYSS051ExT5vZ7lQoemZMl9hTc8RsE3//2Q==","sizes":"(max-width: 750px) 100vw, 750px","src":"/static/6dc1a1b98e66073dbd7e7471a7fff24c/9f583/dockerswarm-vs-kubernetes.jpg","srcSet":"/static/6dc1a1b98e66073dbd7e7471a7fff24c/9f583/dockerswarm-vs-kubernetes.jpg 750w"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/dockerSwarm-vs-kubernetes/"}},"primaryTag":"Sequelize","primaryCategory":"Node.js"}}}