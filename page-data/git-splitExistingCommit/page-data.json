{"componentChunkName":"component---src-templates-post-tsx","path":"/git-splitExistingCommit/","webpackCompilationHash":"28b74a5dec589e4586df","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABFUlEQVQY023PvUrDUBTA8ZuCtoMoOLQ4dWhN14x2kEKXFkGoohQ/QBexOHRycAidKkgHHRq69APRoTjFJYODIA6+gSBYfYMmfYLE/5VT6NALP845NyeHc9UoCHZRQvonCLKKE4ZhAXYURTsYoE9dIy5iCzfUJnEdV+RF4iu6ikFH2EPxazzOcJmg4Rnn5C8ysIEOHqTe5/sT3qXOwYOtRr5/wLAqzpCTDXu4p2ETtyjgGJ/cX+se8jeU9fa4RBt5vWENpjzdkoGPcGg4RQsbOMEFmnBRRwVDHEK/yFXfvr/CoPjvZLKcdByDyzWGeajigzorGy0oOeRJiUtITe/pX1XzDk3buIMltSFR/zTtic3060X+8z8PsEUt8G3LVQAAAABJRU5ErkJggg==","width":400,"height":128,"src":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png","srcSet":"/static/2b5eaa0de166a8b5faebad4955c2200c/647de/ghost-logo.png 1x"}}},"markdownRemark":{"html":"<p>L‚Äôune des principales diff√©rences entre <code>git</code> et les autres syst√®mes de contr√¥le de version est qu‚Äôil permet √† l‚Äôutilisateur de r√©√©crire l‚Äôhistorique. Pour ce faire, le moyen principal consiste √† utiliser <code>git rebase</code>, g√©n√©ralement suivi d‚Äôun <code>git push --force</code> pour √©craser l‚Äôhistorique du serveur (remote) avec l‚Äôhistorique local.</p>\n<p>Voici comment diviser les commits existants √† l‚Äôaide de <code>rebase</code>, <code>reset</code> et <code>commit</code>.</p>\n<p>Supposons que vous ayez deux fichiers √©dit√©s dans un commit (A et B) et que vous souhaitiez importer les modifications d‚Äôun de ces fichiers (A) dans votre branche actuelle, mais pas celles de l‚Äôautre (B).</p>\n<p>Utiliser <code>git cherry-pick &#x3C;commit-hash></code> n‚Äôest pas une option, car cela impliquerait les modifications pour A et B.</p>\n<p>La solution consiste √† scinder le commit en 2 et √† ne s√©lectionner que le nouveau commit contenant les modifications pour A.</p>\n<p>Pour faire √ßa:</p>\n<ul>\n<li>lancez <code>git rebase -i &#x3C;commit-hash>~</code> (notez le <code>-</code>) ou <code>git rebase -i &#x3C;hash-of-previous-commit></code></li>\n<li>recherchez le commit que vous voulez scinder dans l‚Äô√©cran d‚Äô√©dition du rebase, changez le <code>pick</code> en <code>e</code> (<strong>edit</strong>)</li>\n<li>sauvegardez et quittez (<code>ESC</code> suivi de <code>:wq</code> pour fermer VIM)</li>\n<li><code>git reset HEAD~</code> pour r√©initialiser les modifications planifi√©es (<code>stash</code>)</li>\n<li><code>git add [files-to-add]</code> tous les fichiers que nous voulons ajouter au premier commit (ici, ce serait <code>git add A</code>)</li>\n<li><code>git commit</code> normalement, avec un message, etc.</li>\n<li>\n<p>Ex√©cutez autant de fois que vous le souhaitez:</p>\n<ul>\n<li><code>git add [other-files-to-add]</code></li>\n<li><code>git commit</code></li>\n</ul>\n</li>\n<li><code>git rebase -- continue</code> d‚Äôindiquer que la division est termin√©e et continue la refonte</li>\n</ul>\n<p>Enfin, nous pouvons <code>git cherry-pick &#x3C;new-commit-hash></code> pour int√©grer les modifications dans notre branche.</p>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"L‚Äôune des principales diff√©rences entre "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git"}]},{"type":"text","value":" et les autres syst√®mes de contr√¥le de version est qu‚Äôil permet √† l‚Äôutilisateur de r√©√©crire l‚Äôhistorique. Pour ce faire, le moyen principal consiste √† utiliser "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git rebase"}]},{"type":"text","value":", g√©n√©ralement suivi d‚Äôun "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git push --force"}]},{"type":"text","value":" pour √©craser l‚Äôhistorique du serveur (remote) avec l‚Äôhistorique local."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Voici comment diviser les commits existants √† l‚Äôaide de "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"rebase"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"reset"}]},{"type":"text","value":" et "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"commit"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Supposons que vous ayez deux fichiers √©dit√©s dans un commit (A et B) et que vous souhaitiez importer les modifications d‚Äôun de ces fichiers (A) dans votre branche actuelle, mais pas celles de l‚Äôautre (B)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Utiliser "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git cherry-pick <commit-hash>"}]},{"type":"text","value":" n‚Äôest pas une option, car cela impliquerait les modifications pour A et B."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"La solution consiste √† scinder le commit en 2 et √† ne s√©lectionner que le nouveau commit contenant les modifications pour A."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pour faire √ßa:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"lancez "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git rebase -i <commit-hash>~"}]},{"type":"text","value":" (notez le "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"-"}]},{"type":"text","value":") ou "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git rebase -i <hash-of-previous-commit>"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"recherchez le commit que vous voulez scinder dans l‚Äô√©cran d‚Äô√©dition du rebase, changez le "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"pick"}]},{"type":"text","value":" en "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"e"}]},{"type":"text","value":" ("},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"edit"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"sauvegardez et quittez ("},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"ESC"}]},{"type":"text","value":" suivi de "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":":wq"}]},{"type":"text","value":" pour fermer VIM)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git reset HEAD~"}]},{"type":"text","value":" pour r√©initialiser les modifications planifi√©es ("},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"stash"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git add [files-to-add]"}]},{"type":"text","value":" tous les fichiers que nous voulons ajouter au premier commit (ici, ce serait "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git add A"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git commit"}]},{"type":"text","value":" normalement, avec un message, etc."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ex√©cutez autant de fois que vous le souhaitez:"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git add [other-files-to-add]"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git commit"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git rebase -- continue"}]},{"type":"text","value":" d‚Äôindiquer que la division est termin√©e et continue la refonte"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Enfin, nous pouvons "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"git cherry-pick <new-commit-hash>"}]},{"type":"text","value":" pour int√©grer les modifications dans notre branche."}]}],"data":{"quirksMode":false}},"excerpt":"L‚Äôune des principales diff√©rences entre git et les autres syst√®mes de contr√¥le de version est qu‚Äôil permet √† l‚Äôutilisateur de r√©√©crire l‚Äôhistorique. Pour ce faire, le moyen principal consiste √† utiliser git rebase, g√©n√©ralement suivi d‚Äôun git push --force pour √©craser l‚Äôhistorique du serveur (remote) avec l‚Äôhistorique local. Voici comment diviser les commits existants √† l‚Äôaide de rebase, reset et commit. Supposons que vous ayez deux fichiers √©dit√©s dans un commit (A et B) et que vous souhaitiez importer les modifications d‚Äôun de ces fichiers (A) dans votre branche actuelle, mais pas celles de l‚Äôautre (B). Utiliser git cherry-pick <commit-hash> n‚Äôest pas une option, car cela impliquerait les modifications pour A et B. La solution consiste √† scinder le commit en 2 et √† ne s√©lectionner que le nouveau commit contenant les modifications pour A. Pour faire √ßa: lancez git rebase -i <commit-hash>~ (notez le -) ou git rebase -i <hash-of-previous-commit> recherchez le commit que vous voulez scinder dans l‚Äô√©cran d‚Äô√©dition du rebase, changez le pick en e (edit) sauvegardez et quittez (ESC suivi de :wq pour fermer VIM) git reset HEAD~ pour r√©initialiser les modifications planifi√©es (stash) git add [files-to-add] tous les fichiers que nous voulons ajouter au premier commit (ici, ce serait git add A) git commit normalement, avec un message, etc. Ex√©cutez autant de fois que vous le souhaitez: git add [other-files-to-add] git commit git rebase -- continue d‚Äôindiquer que la division est termin√©e et continue la refonte Enfin, nous pouvons git cherry-pick <new-commit-hash> pour int√©grer les modifications dans notre branche.","timeToRead":1,"frontmatter":{"title":"Fractionner un commit existant","subtitle":"Une des choses les plus grandes et les pires avec git est que vous pouvez r√©√©crire l'histoire. Voici une fa√ßon sournoise d'abuser de cela, je ne peux pas penser √† une raison l√©gitime de le faire.","userDate":"8 May 2019","date":"2019-05-08T08:00:00.000Z","tags":["Git","Bash"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHLd3SQoD//xAAZEAACAwEAAAAAAAAAAAAAAAAAAgESIQP/2gAIAQEAAQUCVNnmSpGFmLMf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRABAAIDAAAAAAAAAAAAAAAAACExATJB/9oACAEBAAY/ApdQttlb/8QAHBABAAICAwEAAAAAAAAAAAAAAQARITFBYYGx/9oACAEBAAE/IaOHqJg+Io5YgtYrlm09iTvP/9oADAMBAAIAAwAAABDT7//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAwEBPxCRj//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQEBAAIDAQAAAAAAAAAAAAERACFBMVFhgf/aAAgBAQABPxAQhQtQietJZHLenHejKfTMgmjscy8F4tZAB/u//9k=","aspectRatio":1.6246953696181965,"src":"/static/6367e3250bf5dd6b3387bdab9a38b098/883ab/lumberjack.jpg","srcSet":"/static/6367e3250bf5dd6b3387bdab9a38b098/f8f18/lumberjack.jpg 930w,\n/static/6367e3250bf5dd6b3387bdab9a38b098/0e6ff/lumberjack.jpg 1860w,\n/static/6367e3250bf5dd6b3387bdab9a38b098/883ab/lumberjack.jpg 2000w","sizes":"(max-width: 2000px) 100vw, 2000px"}}},"author":{"id":"ludo","name":"Wyffels Ludovic","bio":"D√©veloppeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsSAAALEgHS3X78AAABMUlEQVQ4y2MwsXf5T03MMGogGBvbOYNpUwdXOIbJwdgwNQQNhCk0snX6r2thC8Y6QGxg7QCWA/FBcrgMxepCkAZrV6//EYmpYBydkvHfMzjiv5mj2//whJT/Nm7ecEMJGgjykp6V/f+AqLj/O/Ye+L8diA8dO/m/pbv/v72n3/+tu/f9D45N/K9naYcSFESFoRXQlSCX2rh7g/kgr1u5epIWhiAMCi/3wLD/fVNn/u+fNgtMT5g+6//kmXOB/Jn/PYLCwWrINnDijDlAPBvKJ8NAZC+DIgCkGYRBbJAYSV5GjpTte/b/PwiMkLj0nP8xqVn/Dxw9AY6kwOh40iIFlmzCgUkmKjnjvx0wdu08fMFskJi1mxfxyQY9YetAEzJyQic5YaNnPeTgIDnrjZaHJGMACtTMXoVAJ6sAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png","srcSet":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png 1x"}}]}}}},"relatedPosts":{"totalCount":5,"edges":[{"node":{"id":"a7b23c0d-9c79-54c7-8132-41d2f4632b4c","timeToRead":1,"excerpt":"Une des choses les plus grandes et les pires avec git est que vous pouvez r√©√©crire l‚Äôhistoire. Voici une fa√ßon sournoise d‚Äôabuser de cela, je ne peux pas penser √† une raison l√©gitime de le faire. Comme pour tout, merci StackOverflow pour toutes les options que je peux choisir parmi Fixe la date du dernier commit √† la date du jour Fixer la date du dernier commit √† une date arbitraire D√©finir la date d‚Äôune validation arbitraire sur une date arbitraire ou courante Rebaser avant ledit engagement et arr√™ter pour modification: git rebase <commit-hash>^ -i Remplace pick par e (edit) sur la ligne avec ce commit (le premier) Quittez l‚Äô√©diteur (ESC suivi de :wq dans VIM) Non plus: GIT_COMMITTER_DATE=\"$(date)\" git commit --amend --no-edit --date \"$(date)\" GIT_COMMITTER_DATE=\"Mon 20 Aug 2018 20:19:19 BST\" git commit --amend --no-edit --date \"Mon 20 Aug 2018 20:19:19 BST\" Voir ici pour plus d‚Äôinformations sur le rebase et l‚Äô√©dition dans git: Fractionner un commit git existant. Apr√®s l‚Äôune de ces 3 options, vous voudrez ex√©cuter:","frontmatter":{"title":"Changer la date d'un commit","subtitle":"Une des choses les plus grandes et les pires avec git est que vous pouvez r√©√©crire l'histoire. Voici une fa√ßon sournoise d'abuser de cela, je ne peux pas penser √† une raison l√©gitime de le faire."},"fields":{"slug":"/git-changeGitOfCommit/"}}},{"node":{"id":"044eb1a1-d28b-5edd-bca2-052da2b0b1bd","timeToRead":7,"excerpt":"Dans cet article, vous apprendrez √† cr√©er et √† g√©rer facilement des git hooks pour vos projets Node/NPM √† l‚Äôaide de Husky. Git Hooks En termes simples, les git hooks sont des scripts personnalis√©s, qui peuvent √™tre ex√©cut√©s automatiquement lorsque des √©v√©nements sp√©cifiques se produisent. Des crochets (hooks) c√¥t√© client sont d√©clench√©s pour des actions telles que le commit ou le merge. Les crochets c√¥t√© serveur s‚Äôex√©cutent dans des situations telles que la r√©ception de donn√©es (git push) du client. Les hooks peuvent ex√©cuter n‚Äôimporte quelle logique personnalis√©e et, plus important encore, rejeter l‚Äôaction effectu√©e si quelque chose ne va pas. Par exemple, vous pouvez annuler la validation du commit si son message ne contient pas l‚ÄôID de probl√®me du suivi des probl√®mes. Vous pouvez √©galement le refuser si l‚Äôanalyse de code statique √©choue. Cela peut √™tre tr√®s utile si vous voulez vous assurer que votre base de code reste propre ou si vous souhaitez appliquer certaines r√®gles de qualit√©. Mais comment pouvez-vous r√©ellement installer et g√©rer ces hooks? Chaque fois que vous clonez un repo git, toutes les donn√©es git de votre projet sont stock√©es dans un r√©pertoire .git dans votre dossier. Il contient plusieurs fichiers et sous-r√©pertoires, l‚Äôun d‚Äôeux √©tant appel√© \u001dhooks\u001d. √Ä l‚Äôint√©rieur, vous trouverez un tas de fichiers.  Chacun d‚Äôentre eux est un script, qui est ex√©cut√© lorsqu‚Äôun √©v√©nement sp√©cifique se produit. Le nom de l‚Äô√©v√©nement correspond au nom du fichier. Par exemple, la \u001dpre-commit\u001d est ex√©cut√©e avant de commiter vos modifications. Comme vous pouvez le constater, tous les fichiers ont une extension \u001d.sample\u001d. Git ignore ces fichiers √† moins que vous ne les renommiez. Vous devez supprimer l‚Äôextension \u001d.sample\u001d pour activer ces hooks. Dans les exemples de fichiers, vous pouvez trouver une description et un exemple d‚Äôimpl√©mentation que vous pouvez utiliser comme point de d√©part pour impl√©menter vos propres hooks. √Ä quoi √ßa sert? Maintenant, regardons quelques exemples sp√©cifiques de ce qui peut √™tre r√©alis√© avec les git hooks. Comme ce ne sont que des scripts, vous pouvez faire √† peu pr√®s n‚Äôimporte quoi. Habituellement, cela signifie effectuer divers contr√¥les de qualit√©. Vous pouvez vous assurer que l‚Äôutilisateur a son nom et son email renseign√©s. Vous pouvez v√©rifier que le message de validation est correctement format√©. Vous pouvez essayer de cr√©er votre application et rejeter le commit si la construction √©choue. Vous pouvez ex√©cuter des tests pour vous assurer qu‚Äôils passent avant le commit. L‚Äôutilisation typique est √©galement l‚Äôanalyse de code statique ou le formatage. Cela signifie qu‚Äôil faut v√©rifier dans votre code les probl√®mes courants, les mauvaises pratiques, les conventions de d√©nomination, etc. Il peut √©galement √™tre utile d‚Äôex√©cuter un outil tel que Prettier pour s‚Äôassurer que le code est bien format√© avant le commit. Cela √©vite de nombreux maux de t√™te lors de la r√©vision du code. Vous pouvez m√™me v√©rifier les failles de s√©curit√© de votre code avec un outil tel que Snyk. Distribution aux membres de l‚Äô√©quipe Avec les hooks c√¥t√© serveur, la distribution est facile. Vous n‚Äôavez g√©n√©ralement qu‚Äôun seul r√©f√©rentiel de serveur principal. Cela signifie que tous les membres de l‚Äô√©quipe mettent g√©n√©ralement leurs modifications au m√™me endroit. Vous y installez vos hooks et vous avez termin√©. Avec les hooks c√¥t√© client, cela devient plus compliqu√©. Lorsque vous clonez un r√©f√©rentiel, les hooks ne sont pas transf√©r√©s au client. Cela signifie qu‚Äôun r√©f√©rentiel fra√Æchement clon√© n‚Äôa aucun hook, peu importe le type de hook que vous avez sur le serveur. Si vous voulez que les membres de votre √©quipe aient un ensemble unifi√© de git hooks, vous devez les distribuer d‚Äôune mani√®re ou d‚Äôune autre et vous assurer qu‚Äôils sont inclus dans leur sous-r√©pertoire git hooks. La solution la plus √©l√©mentaire consiste √† cr√©er un emplacement partag√©, o√π vous stockez vos hooks, puis demandez √† vos d√©veloppeurs de les t√©l√©charger et de les mettre dans leur r√©pertoire de hooks. Bien s√ªr, vous ne pouvez pas √™tre s√ªr qu‚Äôils le feront r√©ellement. Le probl√®me est qu‚Äôils ont besoin de savoir qu‚Äôils devraient le faire et comment. Et m√™me s‚Äôils le font, ils peuvent √™tre paresseux ou simplement ignorer votre politique. Vous pouvez am√©liorer un peu cette solution de base en ayant des hooks dans le r√©f√©rentiel de votre projet et en laissant simplement √† vos d√©veloppeurs ex√©cuter un script personnalis√© comme celui-ci, qui les copie ensuite dans leur r√©pertoire de hooks. Sinon, git propose une option pour changer la destination du r√©pertoire des hooks en un emplacement personnalis√©: Ces solutions facilitent la distribution, mais ne r√©solvent pas les probl√®mes essentiels. Husky Installation Vous pouvez installer Husky simplement en ex√©cutant: Alternative, avec yarn: Ajout de hooks Ajouter des hooks avec Husky est facile. Vous devez juste √©diter votre package.json. Vous d√©finissez quels scripts doivent √™tre ex√©cut√©s sur quel √©v√©nement git. Pour Husky 1.0.0+, utilisez: Si vous utilisez une version de Husky ant√©rieure √† 1.0.0 (disponible dans la version candidate du 06/2018), la syntaxe est l√©g√®rement diff√©rente. Vous ajoutez vos hooks Husky directement dans la section scripts. L‚Äôexemple ci-dessus ex√©cute tous vos tests avant de commiter et avant de pousser et si vos tests √©chouent, l‚Äôaction git n‚Äôest pas ex√©cut√©e. Bien s√ªr, vous pouvez ex√©cuter tout autre script nom plut√¥t que le nom test. Probl√®me de correction automatique avant validation Il est utile de casser le build si quelque chose ne va pas, mais il est encore plus utile de corriger automatiquement les probl√®mes avant de s‚Äôengager. Par exemple, vous pouvez personnaliser votre code en utilisant Prettier avant de faire un commit ou vous pouvez corriger automatiquement les probl√®mes de formatage, qui peuvent √™tre r√©solus automatiquement. C‚Äôest beaucoup plus facile de cette fa√ßon. Heureusement, il existe un outil pour cela. Cela s‚Äôappelle lint-staged. Vous pouvez l‚Äôinstaller par: Maintenant, sur votre action de pre-commit, vous ex√©cutez directement \u001dlint-staged\u001d au lieu de votre linter. Dans lint-staged, vous d√©finissez ce qui doit √™tre ex√©cut√©: Lorsque vous essayez de commiter maintenant, \u001dlint-staged\u001d peut modifier vos fichiers avant l‚Äôex√©cution de la validation. Cependant, ce qui est vraiment bien, c‚Äôest que vous ne filtrez que les fichiers en attente de validation, et non l‚Äôensemble de votre projet. Cela signifie que l‚Äôensemble du processus est beaucoup plus rapide. Bug JetBrains IDE La bonne nouvelle est que les git hooks configur√©s de cette mani√®re sont ex√©cut√©s non seulement lorsque vous utilisez git √† partir de votre terminal, mais √©galement √† partir d‚Äôun IDE. La mauvaise nouvelle est que les IDE JetBrains (IDEA, Webstorm, ‚Ä¶) ont actuellement un m√©chant bogue (voir IDEA-135454) et ne fonctionnent pas bien avec cette configuration. Le probl√®me n‚Äôest pas r√©solu avant plusieurs ann√©es, mais heureusement, il existe une solution de contournement. Vous devez juste ajouter ce hook post-commit: Bien entendu, il ne s‚Äôagit que d‚Äôune solution de contournement jusqu‚Äô√† ce que le probl√®me soit r√©solu. Le suivi des probl√®mes de JetBrains contient une fonctionnalit√© de vote, alors assurez-vous de voter pour que ce probl√®me soit r√©solu s‚Äôil vous pose probl√®me. Int√©gration continue Une chose √† noter est que Husky installe les hooks uniquement lorsqu‚Äôil ne s‚Äôex√©cute pas sur un serveur d‚Äôint√©gration continue. Husky peut d√©tecter qu‚Äôil est en cours d‚Äôex√©cution dans le cadre d‚Äôun travail CI et n‚Äôinstalle aucun hook. En ignorant Les hooks c√¥t√© client peuvent √™tre utiles, mais vous ne pouvez pas trop compter sur eux. Ils ne sont que le premier niveau de d√©fense. Vous ne pouvez pas √™tre s√ªr √† 100% qu‚Äôils soient ex√©cut√©s. Ils peuvent √™tre ignor√©s √† la demande en ajoutant une option de ligne de commande: Pour rendre les choses encore plus faciles, les hooks peuvent √™tre d√©sactiv√©s √† l‚Äôaide de certaines variables environnementales. Pour cette raison, il est toujours utile d‚Äôappliquer la m√™me fonctionnalit√© sur le serveur. Performance Bien que les hooks cot√©s client tels que le pre-commit puissent s‚Äôav√©rer tr√®s utiles, vous devez garder √† l‚Äôesprit qu‚Äôils prennent un certain temps √† s‚Äôex√©cuter. Les commits, qui sont g√©n√©ralement tr√®s rapides, car ils ne se produisent que sur le client, peuvent prendre soudainement tr√®s longtemps. Vous serez peut-√™tre tent√© d‚Äôex√©cuter tous les tests, l‚Äôanalyse de code statique, les v√©rifications pr√©alables, etc., avant chaque validation. Lorsqu‚Äôun commit prend des ann√©es, vos d√©veloppeurs ne seront pas heureux et seront tent√©s d‚Äôignorer les hooks lors de l‚Äôex√©cution de leurs commandes git. Vous devez donc trouver le bon √©quilibre entre ce qui doit √™tre effectu√© sur le client et ce qui peut √™tre un point d‚Äôacc√®s c√¥t√© serveur. Conclusion Husky est un outil utile qui permet de cr√©er et de g√©rer facilement des hooks git sur le client. Vous n‚Äôavez plus besoin de distribuer vos hooks manuellement. Comme pour tout, gardez le nombre de hooks c√¥t√© client avec mod√©ration afin d‚Äô√©viter les temps d‚Äôex√©cution trop longs.","frontmatter":{"title":"Git hooks avec Husky","subtitle":"En termes simples, les git hooks sont des scripts personnalis√©s, qui peuvent √™tre ex√©cut√©s automatiquement lorsque des √©v√©nements sp√©cifiques se produisent."},"fields":{"slug":"/git-husky/"}}},{"node":{"id":"89da3cdd-4f91-58a2-8d1d-480a0cf11697","timeToRead":4,"excerpt":"Que l‚Äôon soit backend, frontend, il y a une chose qui nous rassemble, c‚Äôest notre gestionnaire de source et son utilisation. Dans cet article, je vais vous pr√©senter le conventional-changelog qui vous permettra de produire un historique de super qualit√© üôå! Le probl√®me Combien d‚Äôentre vous sont tomb√©s sur des projets avec un historique qui ressemble √† cela: ü§ï Comment s‚Äôy retrouver? Comment exploiter un historique qui ne vous donne quasiment jamais d‚Äôinformation. La solution, c‚Äôest d‚Äôutiliser le Conventional-Changelog (oui, on dirait une pub de t√©l√©-achat üòù). Qu‚Äôest-ce que c‚Äôest le conventional-changelog? C‚Äôest bien de vous vendre une solution, mais il faudrait peut-√™tre expliquer ce que c‚Äôest‚Ä¶ en vrai. Le Conventional-Changelog est une mani√®re d‚Äô√©crire ses commits dans les projets. Il existe plusieurs ‚Äúflavours‚Äù, je vais vous d√©tailler la version Angular. Le format est le suivant: Si ce format est bien appliqu√©, cela peut donner ce type de texte de commit : C‚Äôest un peu plus agr√©able √† lire non ? Je vais vous d√©crire les diff√©rentes parties de cette convention et comment bien les utiliser. Type Le type permet de repr√©senter de mani√®re succincte le type d‚Äôaction que vous avez fait sur le projet : feat: Ajout d‚Äôune fonctionnalit√© fix: Correction perf: Am√©lioration des performances docs: Ajout de documentation style: Linting du code refactor: Modification du code, mutualisation et autres modifs afin d‚Äôam√©liorer le projet test: Ajout de tests unitaires, int√©gration, end-to-end chore: T√¢che m√©nag√®re, comme mettre √† jour les d√©pendances, reconfigurer la CI‚Ä¶ On ne peut mettre qu‚Äôun seul type par commit, donc finis les commits qui contiennent une feature et un fix en m√™me temps‚Ä¶ Scope Ici, pas de liste impos√©e, juste le titre de l‚Äô√©l√©ment sur lequel une modification a √©t√© faite. Nous avons tendance √† d√©finir clairement les scopes du projet √† l‚Äôavance afin que tout le monde commit avec les m√™mes scopes. Pour exemple, sur une application orient√©e ‚Äúe-commerce‚Äù, on pourrait avoir les scopes suivants : homepage search my-account product-details order admin Parfois, ce scope peut √™tre omis‚Ä¶ car il n‚Äôy en a pas forc√©ment ou vous avez touch√© √† l‚Äôapplication de mani√®re globale. Dans ce cas, laissez vide üòÖ Et par contre, comme pour le type, il ne peut y avoir qu‚Äôun seul scope. Donc si vous pensez avoir deux scopes‚Ä¶ faites deux commit diff√©rents Subject Le sujet doit contenir une description courte du changement effectu√© dans le commit. Quelques conseils pour formater le message : Utiliser l‚Äôimp√©ratif Utiliser le pr√©sent Pas de 1er lettre en majuscule Pas de point . √† la fin du sujet Body Le body est la partie ‚Äúprincipale‚Äù du commit. J‚Äôai tendance √† dire qu‚Äôelle doit contenir le ‚ÄúPourquoi‚Äù du commit. Si vous avez fait une modification structurante ou si la m√©thode d‚Äôimpl√©mentation est particuli√®re, √©crivez-le dans le body ! C‚Äôest un point de vue qui est personnel, mais je pense que le body est le meilleur endroit pour accueillir un commentaire‚Ä¶ car un message de commit ne se d√©synchronise jamais du code. Footer Cette derni√®re partie permet de placer les r√©f√©rences vers toutes les issues, User stories & co. On s‚Äôen sert g√©n√©ralement pour lier (Linked to) ou cl√¥turer (Closes) les issues directement depuis git. Autre √©l√©ment qui peut √™tre ajout√© dans ce footer est la notion de Breaking Change. Il suffit d‚Äôajouter BREAKING CHANGE: suivi du d√©tail de ce fameux breaking change. Je suis oblig√© d‚Äô√©crire tout cela √† chaque fois? Non, rassurez-vous, vous n‚Äô√™tes pas oblig√©‚Ä¶ m√™me s‚Äôil est bien de mettre un max d‚Äôinformation dans le message de commit. La convention veut que seule la 1√®re ligne soit obligatoire. Donc, libre √† vous, de ne pas mettre de body et de footer Conclusion Avec cette convention, vous prendrez plaisir √† fouiller dans l‚Äôhistorique de votre projet, trouver la source d‚Äôune modification et surtout savoir ‚ÄúPourquoi cela a √©t√© fait comme cela !‚Äù Et quand l‚Äôon regarde, la diff√©rence entre l‚Äôancienne version : et la nouvelle (certes, sur des projets diff√©rents): Cela est quand m√™me bien plus clair ! R√©f√©rence Git Commit Message Conventions","frontmatter":{"title":"Bien g√©rer ses textes de commit (partie 1)","subtitle":"Que l‚Äôon soit backend, frontend, il y a une chose qui nous rassemble, c‚Äôest notre gestionnaire de source et son utilisation. Dans cet article, je vais vous pr√©senter le conventional-changelog qui vous permettra de produire un historique de super qualit√© !"},"fields":{"slug":"/git-manage-commit-text-part1/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/git-splitExistingCommit/","prev":{"excerpt":"Si vous travaillez sur plus d‚Äôun projet √† la fois, travaillez beaucoup en open source ou si vous d√©cidez de revenir √† un projet que vous avez r√©alis√© il y a un an, il y a de fortes chances pour que vous deviez changer de version de Node.js. Il se peut que quelques d√©pendances ne fonctionnent que sur une version de Node.js sp√©cifique. Vous pouvez utiliser nvm pour changer vos versions de node.js en une seconde. Installation Si vous n‚Äôavez pas d√©j√† install√© NVM. T√©l√©chargez et installez la derni√®re version de NVM V√©rifiez votre version de nvm avec Installer un nouvelle version Pour t√©l√©charger et installer une nouvelle version de Node.js, ex√©cutez Remplacez 12.0 par le num√©ro de version dons vous avez besoin. Lister les versions Pour v√©rifier quelles version de Node.js sont install√©es sur votre syst√®me, ex√©cutez Ceci listera toutes les versions que vous avez install√©es. Utiliser une version install√© Pour passer √† n‚Äôimporte quelle version de node.js , vous devez ex√©cuter D√©sinstaller une version Si vous ne voulez pas de version particuli√®re de Node.js, vous devez ex√©cuter Alias Vous pouvez d√©finir la version par d√©faut de Node.js en d√©finissant un alias. Mettre √† jour NPM NVM ne vous permet pas de mettre √† jour uniquement npm, mais uniquement une version node + npm. Mais il existe un moyen tr√®s simple de le faire: Migration des packages global vers une autre version de node Si vous souhaitez installer une nouvelle version de Node.js et migrer les packages npm √† partir d‚Äôune version pr√©c√©dente: Cela utilisera d‚Äôabord ‚Äúnvm version node‚Äù pour identifier la version actuelle √† partir de laquelle vous faites migrer les packages. Il r√©sout ensuite la nouvelle version √† installer √† partir du serveur distant et l‚Äôinstalle. Enfin, il ex√©cute ‚Äúnvminstall-packages‚Äù pour r√©installer les packages npm de votre version pr√©c√©dente de Node vers la nouvelle. Vous pouvez √©galement installer et migrer des packages npm √† partir de versions sp√©cifiques de Node, comme suit: Automatiser le changement de version Pour automatiser le changement de versio de Node.js, il existe un package npm qui s‚Äôappelle AVN qui le permet Maintenant quand vous faites cd dans un r√©pertoire avec un fichier .node-version, avn d√©tectera automatiquement le changement et utilisera votre gestionnaire de version install√© pour passer √† cette version de node. Que contient votre fichier .node-version? Un num√©ro de version semver correspondant √† la version de Node.js que votre projet utilise.","timeToRead":3,"frontmatter":{"title":"Changer d'environnement Node.js","subtitle":"NVM, le moyen le plus simple de changer d'environnement Node.js sur votre machine en un clin d'oeil","tags":["NVM","Node.js"],"category":["Node.js"],"date":"2019-05-07T14:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7777777777777777,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYElEQVQoz4VS206DQBDtz7QVdrkul8WF5VJSgUQjxSY1+qBN6IORWmp94JX+uGOpBmNqz8Nmd2bOOTOTHWCMpR7wH0BQJ+qla3POsYRkWdZ1vascIISGw+FoNOpOQRD6TMiqin73mK0+5tW6MjzRNK00TY9kQsi+3S+Xy6Zp2rYNw3A8HvdbgDsxNObZvu9j+bczkLfvdVmWm82mruskSVRVVRTllLNlWlBjGIYoigMsYR4x7vPJZALa0+m0KApKKeQ6+ePMns19H0lfQU3Tjs4/Dt0FOP0nQqKuGounm5dmsa1rGsqUOnmee54H2zmQJdzfeX9hoOVQJ4h4fBVmWWY7puM4rusyxqC7AT4NEAJ57gX3z7er3fxtvbZ9bFs2qMRxHEXRf+TOGarB9jpPZrMZZZbL3CAIoG2Y/AwZhldkrXhIy11RvVaEXRBiwLZN0/ye+RxEATpAh/8joQO6+CfZy41+l9GVwgAAAABJRU5ErkJggg==","sizes":"(max-width: 1600px) 100vw, 1600px","src":"/static/0dc290e31536b77317d3c03d0845cc22/9ecf6/nvm.png","srcSet":"/static/0dc290e31536b77317d3c03d0845cc22/4c9af/nvm.png 930w,\n/static/0dc290e31536b77317d3c03d0845cc22/9ecf6/nvm.png 1600w"}}},"author":{"id":"ludo","bio":"D√©veloppeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/node-nvm/"}},"next":{"excerpt":"Une des choses les plus grandes et les pires avec git est que vous pouvez r√©√©crire l‚Äôhistoire. Voici une fa√ßon sournoise d‚Äôabuser de cela, je ne peux pas penser √† une raison l√©gitime de le faire. Comme pour tout, merci StackOverflow pour toutes les options que je peux choisir parmi Fixe la date du dernier commit √† la date du jour Fixer la date du dernier commit √† une date arbitraire D√©finir la date d‚Äôune validation arbitraire sur une date arbitraire ou courante Rebaser avant ledit engagement et arr√™ter pour modification: git rebase <commit-hash>^ -i Remplace pick par e (edit) sur la ligne avec ce commit (le premier) Quittez l‚Äô√©diteur (ESC suivi de :wq dans VIM) Non plus: GIT_COMMITTER_DATE=\"$(date)\" git commit --amend --no-edit --date \"$(date)\" GIT_COMMITTER_DATE=\"Mon 20 Aug 2018 20:19:19 BST\" git commit --amend --no-edit --date \"Mon 20 Aug 2018 20:19:19 BST\" Voir ici pour plus d‚Äôinformations sur le rebase et l‚Äô√©dition dans git: Fractionner un commit git existant. Apr√®s l‚Äôune de ces 3 options, vous voudrez ex√©cuter:","timeToRead":1,"frontmatter":{"title":"Changer la date d'un commit","subtitle":"Une des choses les plus grandes et les pires avec git est que vous pouvez r√©√©crire l'histoire. Voici une fa√ßon sournoise d'abuser de cela, je ne peux pas penser √† une raison l√©gitime de le faire.","tags":["Git","Bash"],"category":["Git","Bash"],"date":"2019-05-08T09:00:00.000Z","draft":false,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.4981273408239701,"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeRAQwf/xAAbEAACAQUAAAAAAAAAAAAAAAAAARECAxIhIv/aAAgBAQABBQK4RoVULPk//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAARARADFx/9oACAEBAAY/AhxzYyARf//EABoQAQADAQEBAAAAAAAAAAAAAAEAETEhURD/2gAIAQEAAT8hNcYxUx2WkWwHgzQ4d9+f/9oADAMBAAIAAwAAABAbL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQEBAAIDAQAAAAAAAAAAAAERAFGBITFBcf/aAAgBAQABPxCBiAjqt5bfRjwIPWQXOcH4/NAocqqu3LFob//Z","sizes":"(max-width: 2000px) 100vw, 2000px","src":"/static/84ded7f830441f1151fac27920347fb2/883ab/infinity.jpg","srcSet":"/static/84ded7f830441f1151fac27920347fb2/f8f18/infinity.jpg 930w,\n/static/84ded7f830441f1151fac27920347fb2/0e6ff/infinity.jpg 1860w,\n/static/84ded7f830441f1151fac27920347fb2/883ab/infinity.jpg 2000w"}}},"author":{"id":"ludo","bio":"D√©veloppeur senior. Fullstack + DevOps","avatar":{"children":[{"fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"fields":{"layout":"post","slug":"/git-changeGitOfCommit/"}},"primaryTag":"Git","primaryCategory":"Git"}}}