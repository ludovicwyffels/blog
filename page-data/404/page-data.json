{"componentChunkName":"component---src-pages-404-tsx","path":"/404/","webpackCompilationHash":"28b74a5dec589e4586df","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"timeToRead":4,"frontmatter":{"title":"Jest ignore ou exclut le fichier/fonction/état de la couverture de test","date":"2019-08-18T09:00:00.000Z","tags":["Node.js","Jest","Javascript"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAMCBAH/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAaT9xGmEzPbygxFZ/wD/xAAcEAACAgIDAAAAAAAAAAAAAAAAAQIDERIhIjL/2gAIAQEAAQUC2J1nQfA5YbH5tEf/xAAYEQACAwAAAAAAAAAAAAAAAAAAAgEQEv/aAAgBAwEBPwFmNSPX/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQAQEf/aAAgBAgEBPwELkZ//xAAXEAEBAQEAAAAAAAAAAAAAAAAQAREh/9oACAEBAAY/AjpjKf/EABwQAAICAgMAAAAAAAAAAAAAAAABESExUUFhcf/aAAgBAQABPyHbBC7irLaMSjfODpUWIpwJMmJ6DOD/2gAMAwEAAgADAAAAEHgAwP/EABcRAQEBAQAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QYcl1P//EABYRAQEBAAAAAAAAAAAAAAAAABEAEP/aAAgBAgEBPxBI7//EABsQAQEBAQEAAwAAAAAAAAAAAAERACFBMWFx/9oACAEBAAE/EC2kT85qpApHKq/gG5TwKn01p9Yh9udZx5rLKnTGIciaL13/2Q==","aspectRatio":1,"src":"/static/22ad5d991b79aa0c174819e09d9f9dab/81ef8/cactus.jpg","srcSet":"/static/22ad5d991b79aa0c174819e09d9f9dab/f8f18/cactus.jpg 930w,\n/static/22ad5d991b79aa0c174819e09d9f9dab/81ef8/cactus.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"excerpt":"En génie logiciel, la couverture de code est une mesure utilisée pour décrire le taux de code source exécuté d’un programme quand une suite de test est lancée. Un programme avec une haute couverture de code, mesurée en pourcentage, a davantage de code exécuté durant les tests ce qui laisse à penser qu’il a moins de chance de contenir de bugs logiciels non détectés, comparativement à un programme avec une faible couverture de code1,2. Différentes métriques peuvent être utilisées pour calculer la couverture de code ; les plus basiques sont le pourcentage de sous routine et le pourcentage d’instructions appelées durant l’exécution de la suite de test. Couverture de code - Wikipedia La couverture de code est généralement utilisée comme mesure de qualité pour les logiciels, par exemple: ‘Notre code doit avoir une couverture de tests de 80% et plus.” La collection de la couverture de test avec Jest est aussi simple que l’utilisation de l’indicateur --coverage sur l’invocation. Cet article explique comment ignorer les fichiers, fonctions, lignes et déclarations de la couverture dans Jest en utilisant la configuration ou istanbul pragmas. Ainsi que les raisons et les limites du pourquoi/comment vous feriez une telle chose. Comment Jest calcule-t-il la couverture ? Jest utilise istanbul sous le capot pour calculer la couverture. La plupart du temps, Jest fait abstraction de cela pour l’utilisateur final, tout ce que vous avez à faire dans votre application est d’appeler jest --coverage (et configurer les champs de configuration de couverture appropriés). Le fait qu’istanbul soit utilisé en interne montre, par exemple, que la documentation pour coverageReporters mentionne que “tout reporter d’istanbul peut être utilisé”, ce sont en fait les données de couverture collectées et produites qui sont présentées dans les rapports. Pourquoi voudrais-je exclure ou ignorer des fichiers ou lignes de la couverture ? Comme l’ont déclaré les responsables et les auteurs de la bibliothèque de couverture d’istanbul : Some branches in JS code are typically hard, if not impossible to test. Examples are a hasOwnProperty check, UMD wrappers and so on. Istanbul now has a facility by which coverage can be excluded for certain sections of code. Istanbul - Ignore code for coverage purposes De plus, une couverture à 100 % n’est pas nécessaire ou même raisonnable dans la plupart des cas. Certains fichiers ne contiennent pas de logique (métier). Ou ils contiennent une logique qui échouerait d’une manière très évidente (par exemple, un crash au démarrage). Par exemple, le script qui démarrerait une application pourrait se lier à un port, ce qui la rend difficile à tester. Le fichier qui importe toutes les différentes dépendances et app.use() dans un paramètre Express serait un autre candidat pour peut-être éviter l’enfer du test unitaire/du mock de dépendance. Une autre classe de fichiers/fonctions que vous pourriez vouloir ignorer à des fins de couverture sont les ‘helpers’ spécifiques aux tests. Peu importe que certains d’entre eux ne soient pas exécutés dans le cadre de tests, car ce n’est pas le code à tester. Comme pour beaucoup de choses dans les logiciels, il s’agit de compromis. Exclure/ignorer le(s) fichier(s) de la couverture Jest en n’exécutant pas les tests pertinents à l’aide de la configuration Il y a une option de configuration Jest option testPathIgnorePatterns (voir la documentation pour testPathIgnorePatterns) La façon la plus simple de configurer ceci est de le faire via le fichier package.json : Exclure/ignorer le(s) fichier(s) de la couverture en ne l’incluant pas dans la configuration de la collection de couvertures Comme alternative ou augmentation à ne pas exécuter de tests (comme vu précédemment) de la couverture de Jest en ne l’incluant pas dans les rapports de couverture, cela est contrôlé par l’option de configuration collectCoverageFrom Jest (voir les documents pour Jest collectCoverageFrom). Utilisez quelque chose comme ce qui suit : Important: assurez-vous d’entourer le nom du fichier ignoré avec (). Exclure/ignorer un fichier de la couverture Jest au niveau du fichier Nous pouvons utiliser istanbul pragmas pour ignorer les fichiers en utilisant le commentaire suivant en haut de chaque fichier : Exclure/ignorer la fonction de la couverture Jest Exclure/ignorer une ou plusieurs lignes de la couverture Jest Évitez ceci si vous le pouvez, si vous testez du code, vous devriez probablement tester tout ce code. istanbul ignore next fonctionne également à ignorer les déclarations, définitions et expressions de JS, ce qui équivaut à ignorer/exclure la ligne de la couverture : Exclure/ignorer l’énoncé ou la clause de la couverture Jest Évitez ceci si vous le pouvez, si vous testez du code, vous devriez probablement tester tout ce code. Lectures complémentaires Consultez la documentation originale d’istanbul sur ignorer du code pour la couverture pour un examen plus approfondi de la façon de procéder dans différentes situations.","fields":{"layout":"post","slug":"/jest-exclude-coverage/"}}},{"node":{"timeToRead":2,"frontmatter":{"title":"Bien gérer ses textes de commit (partie 2)","date":"2019-08-11T18:00:00.000Z","tags":["Git","Node.js"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABVLywQM4t/8QAGRABAQEAAwAAAAAAAAAAAAAAAgEAAxIi/9oACAEBAAEFAjYbGa/OO5x2O//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABYRAQEBAAAAAAAAAAAAAAAAAAABEv/aAAgBAgEBPwFiP//EAB0QAAIBBAMAAAAAAAAAAAAAAAABMgIQERIhQVH/2gAIAQEABj8ClwVbPD6JCG/Lf//EABwQAAMAAgMBAAAAAAAAAAAAAAABESExQVGBkf/aAAgBAQABPyGUSNvqLg0lKYL1eiZVcsToWHs//9oADAMBAAIAAwAAABAzL//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ECf/xAAWEQEBAQAAAAAAAAAAAAAAAAABMRD/2gAIAQIBAT8QFjMP/8QAHBABAAICAwEAAAAAAAAAAAAAAQARIUExUZFh/9oACAEBAAE/EAltBA8O42KxjwXf2Jc+6ZIoPW0uXQptIchpjqk//9k=","aspectRatio":1.5056461731493098,"src":"/static/bb024aed8b63b69834a2bfb23baa20cf/81ef8/nature.jpg","srcSet":"/static/bb024aed8b63b69834a2bfb23baa20cf/f8f18/nature.jpg 930w,\n/static/bb024aed8b63b69834a2bfb23baa20cf/81ef8/nature.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"excerpt":"Nous sommes tous passés par là. Qu’il s’agisse d’un calendrier serré, de corrections constantes ou simplement de la création de messages avec notre propre modèle défini; nous avons tous fait de mauvais messages de commit. Heureusement pour nous, la spécification Conventional Commits existe, et avec elle un ensemble d’outils puissants pour nous aider. Application d’une norme Pour faire respecter une norme à chaque fois que nous nous faisons un commit, nous avons husky et commitling. Husky écoute les git hooks, et nous l’utiliserons pour déclencher le commitlint lorsque nous tapons un message de commit. Maintenant, installons les paquets : Après avoir installé ces paquets, vous devez créer un fichier commitlint.config.js dans le même dossier que votre package.json : Et modifier votre package.json: Tout est prêt! Maintenant, vos messages seront linted. Nous les commitons avec commitizen Commitizen est un paquet qui facilite la création de messages de commit selon la spécification précédente. Pour ce faire, vous devez l’installer globalement et configurer votre projet. Maintenant, faites un changement, ajoutez-le et lancez git cz. Automatisation Nous avons ajouté des outils pour assurer et faciliter la validation des messages de commit selon les spécifications conventionnelles de commit. Non seulement nous avons reçu des messages standard sur l’ensemble du projet que les humains peuvent lire, mais aussi des machines. Oui, des machines. Le respect de ces normes a permis aux machines de comprendre le motif, et avec cela, de mettre à jour automatiquement la version de nos paquets et de générer des changelogs. Version bumping et CHANGELOG Pour faire les deux actions, nous n’avons besoin que d’un seul paquet, standard-version. Ce paquet le fera: Analyser vos engagements depuis votre dernière version (tag) Version bump votre paquet.json Générer ou mettre à jour un fichier CHANGELOG.md Générer un message de livraison Générer une nouvelle balise Utilisons-la donc : Mettez à jour votre paquet.json : Et maintenant vous n’avez plus qu’à lancer npm run release. Alternativement, si vous souhaitez simplement générer un fichier changelog, je vous recommande le fichier conventionnel-changelog-cli. Quelle est la prochaine étape? Après avoir gagné en lisibilité et en automatisation des tâches quotidiennes douloureuses, vous pouvez créer votre propre standard basé sur les spécifications conventionnelles de commit. La famille d’outils conventionnel-changelog vous permet et vous facilite la création de votre propre version si vous le souhaitez. J’espère que ce message vous a aidé. S’il y a quoi que ce soit, partagez de l’information qui pourrait l’améliorer et la rendre meilleure pour les autres!","fields":{"layout":"post","slug":"/git-manage-commit-text-part2/"}}},{"node":{"timeToRead":4,"frontmatter":{"title":"Bien gérer ses textes de commit (partie 1)","date":"2019-08-11T08:00:00.000Z","tags":["Git","Node.js"],"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABVLywQM4t/8QAGRABAQEAAwAAAAAAAAAAAAAAAgEAAxIi/9oACAEBAAEFAjYbGa/OO5x2O//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABYRAQEBAAAAAAAAAAAAAAAAAAABEv/aAAgBAgEBPwFiP//EAB0QAAIBBAMAAAAAAAAAAAAAAAABMgIQERIhQVH/2gAIAQEABj8ClwVbPD6JCG/Lf//EABwQAAMAAgMBAAAAAAAAAAAAAAABESExQVGBkf/aAAgBAQABPyGUSNvqLg0lKYL1eiZVcsToWHs//9oADAMBAAIAAwAAABAzL//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ECf/xAAWEQEBAQAAAAAAAAAAAAAAAAABMRD/2gAIAQIBAT8QFjMP/8QAHBABAAICAwEAAAAAAAAAAAAAAQARIUExUZFh/9oACAEBAAE/EAltBA8O42KxjwXf2Jc+6ZIoPW0uXQptIchpjqk//9k=","aspectRatio":1.5056461731493098,"src":"/static/bb024aed8b63b69834a2bfb23baa20cf/81ef8/nature.jpg","srcSet":"/static/bb024aed8b63b69834a2bfb23baa20cf/f8f18/nature.jpg 930w,\n/static/bb024aed8b63b69834a2bfb23baa20cf/81ef8/nature.jpg 1200w","sizes":"(max-width: 1200px) 100vw, 1200px"}}},"author":{"id":"ludo","bio":"Développeur senior. Fullstack + DevOps","avatar":{"children":[{"__typename":"ImageSharp","fixed":{"src":"/static/5f2c129e42248a92c87b13b4293950cf/4e842/ghost.png"}}]}}},"excerpt":"Que l’on soit backend, frontend, il y a une chose qui nous rassemble, c’est notre gestionnaire de source et son utilisation. Dans cet article, je vais vous présenter le conventional-changelog qui vous permettra de produire un historique de super qualité 🙌! Le problème Combien d’entre vous sont tombés sur des projets avec un historique qui ressemble à cela: 🤕 Comment s’y retrouver? Comment exploiter un historique qui ne vous donne quasiment jamais d’information. La solution, c’est d’utiliser le Conventional-Changelog (oui, on dirait une pub de télé-achat 😝). Qu’est-ce que c’est le conventional-changelog? C’est bien de vous vendre une solution, mais il faudrait peut-être expliquer ce que c’est… en vrai. Le Conventional-Changelog est une manière d’écrire ses commits dans les projets. Il existe plusieurs “flavours”, je vais vous détailler la version Angular. Le format est le suivant: Si ce format est bien appliqué, cela peut donner ce type de texte de commit : C’est un peu plus agréable à lire non ? Je vais vous décrire les différentes parties de cette convention et comment bien les utiliser. Type Le type permet de représenter de manière succincte le type d’action que vous avez fait sur le projet : feat: Ajout d’une fonctionnalité fix: Correction perf: Amélioration des performances docs: Ajout de documentation style: Linting du code refactor: Modification du code, mutualisation et autres modifs afin d’améliorer le projet test: Ajout de tests unitaires, intégration, end-to-end chore: Tâche ménagère, comme mettre à jour les dépendances, reconfigurer la CI… On ne peut mettre qu’un seul type par commit, donc finis les commits qui contiennent une feature et un fix en même temps… Scope Ici, pas de liste imposée, juste le titre de l’élément sur lequel une modification a été faite. Nous avons tendance à définir clairement les scopes du projet à l’avance afin que tout le monde commit avec les mêmes scopes. Pour exemple, sur une application orientée “e-commerce”, on pourrait avoir les scopes suivants : homepage search my-account product-details order admin Parfois, ce scope peut être omis… car il n’y en a pas forcément ou vous avez touché à l’application de manière globale. Dans ce cas, laissez vide 😅 Et par contre, comme pour le type, il ne peut y avoir qu’un seul scope. Donc si vous pensez avoir deux scopes… faites deux commit différents Subject Le sujet doit contenir une description courte du changement effectué dans le commit. Quelques conseils pour formater le message : Utiliser l’impératif Utiliser le présent Pas de 1er lettre en majuscule Pas de point . à la fin du sujet Body Le body est la partie “principale” du commit. J’ai tendance à dire qu’elle doit contenir le “Pourquoi” du commit. Si vous avez fait une modification structurante ou si la méthode d’implémentation est particulière, écrivez-le dans le body ! C’est un point de vue qui est personnel, mais je pense que le body est le meilleur endroit pour accueillir un commentaire… car un message de commit ne se désynchronise jamais du code. Footer Cette dernière partie permet de placer les références vers toutes les issues, User stories & co. On s’en sert généralement pour lier (Linked to) ou clôturer (Closes) les issues directement depuis git. Autre élément qui peut être ajouté dans ce footer est la notion de Breaking Change. Il suffit d’ajouter BREAKING CHANGE: suivi du détail de ce fameux breaking change. Je suis obligé d’écrire tout cela à chaque fois? Non, rassurez-vous, vous n’êtes pas obligé… même s’il est bien de mettre un max d’information dans le message de commit. La convention veut que seule la 1ère ligne soit obligatoire. Donc, libre à vous, de ne pas mettre de body et de footer Conclusion Avec cette convention, vous prendrez plaisir à fouiller dans l’historique de votre projet, trouver la source d’une modification et surtout savoir “Pourquoi cela a été fait comme cela !” Et quand l’on regarde, la différence entre l’ancienne version : et la nouvelle (certes, sur des projets différents): Cela est quand même bien plus clair ! Référence Git Commit Message Conventions","fields":{"layout":"post","slug":"/git-manage-commit-text-part1/"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":true}}}